#include <stdio.h>

void lisplib_fs_term_bind( fp )
     FILE *fp;
{
  LISP_SEND(fp,"(defun fs-term-bind (lst)\n");
  LISP_SEND(fp,"  (cond \n");
  LISP_SEND(fp,"   ((atom lst) (list (fs-term-bind-single lst)))\n");
  LISP_SEND(fp,"   ((not (eq '+ (car lst))) (list (fs-term-bind-single lst)))\n");
  LISP_SEND(fp,"					;うえの二つは連想リストを返す\n");
  LISP_SEND(fp,"   (t\n");
  LISP_SEND(fp,"    (do ((dlst (cdr lst) (cdr dlst))\n");
  LISP_SEND(fp,"	 (result  nil              ) )      ; result は連想リスト\n");
  LISP_SEND(fp,"	((null dlst) result)\n");
  LISP_SEND(fp,"	(let* ( (item (fs-term-bind-single (car dlst))) \n");
  LISP_SEND(fp,"					;itemは記録すべきドット対\n");
  LISP_SEND(fp,"		(obj  (assoc (car item) result :test (function equal))     ) )\n");
  LISP_SEND(fp,"					;obj は該当項のドット対\n");
  LISP_SEND(fp,"\n");
  LISP_SEND(fp,"\n");
  LISP_SEND(fp,"	  (if (not (null item))         ;itemが０でない時だけ処理する！！！\n");
  LISP_SEND(fp,"	      (if (null obj)                    \n");
  LISP_SEND(fp,"					;nullのとき、itemは新顔ということ\n");
  LISP_SEND(fp,"		  (setq result (cons item result))\n");
  LISP_SEND(fp,"		(let ((num (+ (cdr item) (cdr obj))))\n");
  LISP_SEND(fp,"					;係数を計算して\n");
  LISP_SEND(fp,"					;０の場合を除外する。\n");
  LISP_SEND(fp,"		  (if (eq num 0)\n");
  LISP_SEND(fp,"		      (setq result (remove obj result))\n");
  LISP_SEND(fp,"					;たした結果（num）を代入する\n");
  LISP_SEND(fp,"		    (setf (cdr (assoc (car item) result :test (function equal))) num))))))))))\n");
  LISP_SEND(fp,"\n");
  LISP_SEND(fp,"(defun fs-term-bind-single (lst)\n");
  LISP_SEND(fp,"  (cond ((numberp lst) (cons 1 lst))    ; 数値の場合\n");
  LISP_SEND(fp,"	((atom    lst) (cons lst 1))    ; シンボルの場合\n");
  LISP_SEND(fp,"	((not (eq '* (car lst)))        ; かけ算以外の場合、将来複雑な関数\n");
  LISP_SEND(fp,"					; を扱う場合ここも表現に一意性が保\n");
  LISP_SEND(fp,"					; たれるようにしなければいけない\n");
  LISP_SEND(fp,"	                                ; 現状では、単に単項にしているだけ\n");
  LISP_SEND(fp,"	 (cons lst 1))\n");
  LISP_SEND(fp,"	((member 0 lst) '(1 . 0))            ; かけると０になる\n");
  LISP_SEND(fp,"	(t\n");
  LISP_SEND(fp,"	 (do*(( num     1       )       ;係数\n");
  LISP_SEND(fp,"	      ( sbl   nil       )       ;単項\n");
  LISP_SEND(fp,"	      ( fnc   nil       )       ;関数\n");
  LISP_SEND(fp,"              ( alst  nil       )       ;連想リスト\n");
  LISP_SEND(fp,"              ( dlst (cdr lst) (cdr dlst))   ;do 制御リスト\n");
  LISP_SEND(fp,"	      ( item (car dlst) (car dlst))) ;do 制御のかー\n");
  LISP_SEND(fp,"	     ((null dlst) (cons (mk-tb-sngl-car alst sbl fnc) num))\n");
  LISP_SEND(fp,"	     (cond ((numberp item) (setq num (* num item)))  ; 数値係数項\n");
  LISP_SEND(fp,"		   ((atom    item) \n");
  LISP_SEND(fp,"		    (if (member item sbl)      ;既に該当項がある場合\n");
  LISP_SEND(fp,"			(let ((cof (cdr (assoc item alst :test (function equal)))))\n");
  LISP_SEND(fp,"			  (setf (cdr (assoc item alst :test (function equal))) (+ cof 1)))\n");
  LISP_SEND(fp,"					       ;該当項がない場合\n");
  LISP_SEND(fp,"		      (setq  sbl  (cons item sbl)\n");
  LISP_SEND(fp,"			     alst (cons (cons item 1) alst))))\n");
  LISP_SEND(fp,"					;冪乗項の場合\n");
  LISP_SEND(fp,"		   ((eq '^ (car item))\n");
  LISP_SEND(fp,"		    (let ( (cof2 (caddr item))      ; 指数\n");
  LISP_SEND(fp,"			   (sbl2 (cadr  item)) )    ; 底\n");
  LISP_SEND(fp,"		      (cond ((atom sbl2)            ; 底がシンボルの場合\n");
  LISP_SEND(fp,"			     (if (member sbl2 sbl)\n");
  LISP_SEND(fp,"				 (let ((cof3\n");
  LISP_SEND(fp,"					(cdr (assoc sbl2 alst :test (function equal)))))\n");
  LISP_SEND(fp,"				   (setf (cdr (assoc sbl2 alst :test (function equal))) (+ cof3 cof2)))\n");
  LISP_SEND(fp,"			       (setq sbl (cons sbl2 sbl)\n");
  LISP_SEND(fp,"				     alst (cons (cons sbl2 cof2) alst))))\n");
  LISP_SEND(fp,"					;底がリストの場合\n");
  LISP_SEND(fp,"			    (t (if (member sbl2 fnc) ; 注意！！fncはそーちんぐ\n");
  LISP_SEND(fp,"                                                     ; していない（拡張予定）\n");
  LISP_SEND(fp,"				   (let ((cof3\n");
  LISP_SEND(fp,"					  (assoc sbl2 alst :test (function equal))))\n");
  LISP_SEND(fp,"				     (setf (cdr (assoc sbl2 alst :test (function equal))) (+ cof2 cof3)))\n");
  LISP_SEND(fp,"				 (setq fnc (cons sbl2 fnc)\n");
  LISP_SEND(fp,"				       alst (cons (cons sbl2 cof2) alst)))))))\n");
  LISP_SEND(fp,"					; リストの場合、表現の一意性に注意！！\n");
  LISP_SEND(fp,"		   (t (if (member item fnc )\n");
  LISP_SEND(fp,"			  (let ((cof3 (assoc item alst :test (function equal))))\n");
  LISP_SEND(fp,"			    (setf (cdr assoc item alst :test (function equal))\n");
  LISP_SEND(fp,"				  (+ cof3 1)))\n");
  LISP_SEND(fp,"			(setq fnc (cons item fnc)\n");
  LISP_SEND(fp,"			      alst (cons (cons item 1) alst)))))))))\n");
  LISP_SEND(fp,"(defun mk-tb-sngl-car (alst sbl fnc)\n");
  LISP_SEND(fp,"  (cond ((eq 1 (length alst)) (if (eq 1 (cdar alst)) (caar alst)\n");
  LISP_SEND(fp,"				(cons '^ (list (caar alst) (cdar alst)))))\n");
  LISP_SEND(fp,"	(t\n");
  LISP_SEND(fp,"	 (do ((dlst (append (sbl-sort sbl) (lst-sort fnc)) (cdr dlst))\n");
  LISP_SEND(fp,"	      (rst  nil            ))\n");
  LISP_SEND(fp,"                                       ; dlstの順番に並び替える\n");
  LISP_SEND(fp,"	     ((null dlst) (if (null rst) 1 (cons '* rst)))\n");
  LISP_SEND(fp,"	     (let ((item (assoc (car dlst) alst :test (function equal))))\n");
  LISP_SEND(fp,"	       (if (eq 1 (cdr item))\n");
  LISP_SEND(fp,"		   (setq rst (cons (car item) rst))\n");
  LISP_SEND(fp,"		 (if(eq 0 (cdr item)) nil\n");
  LISP_SEND(fp,"		   (setq rst (append rst \n");
  LISP_SEND(fp,"				     (list (cons '^ \n");
  LISP_SEND(fp,"						 (list (car item) (cdr item)))))))))))))\n");
  LISP_SEND(fp,"\n");
  LISP_SEND(fp,"      \n");
  LISP_SEND(fp,"\n");
  LISP_SEND(fp,"		      \n");
  LISP_SEND(fp,"\n");
  LISP_SEND(fp,"\n");
  LISP_SEND(fp,"\n");
  LISP_SEND(fp,"\n");
  LISP_SEND(fp,"\n");
  LISP_SEND(fp,"\n");
  LISP_SEND(fp,"\n");
  LISP_SEND(fp,"\n");
  LISP_SEND(fp,"\n");
  LISP_SEND(fp,"\n");
  LISP_SEND(fp,"\n");
  LISP_SEND(fp,"\n");
  LISP_SEND(fp,"\n");
  LISP_SEND(fp,"\n");
  LISP_SEND(fp,"\n");
  LISP_SEND(fp,"\n");
  LISP_SEND(fp,"\n");
  LISP_SEND(fp,"\n");
  LISP_SEND(fp,"\n");
  LISP_SEND(fp,"\n");
  LISP_SEND(fp,"\n");
}
