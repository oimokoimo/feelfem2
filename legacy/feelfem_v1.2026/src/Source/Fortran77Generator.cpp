/*
 *  feelfem version 1.0  Copyright(c)  NEC Corporation 1999
 *                       Programmed by Hidehiro  FUJIO
 *
 *  Filename : Fortran77Generator.cpp
 *  Date     : 1999/10/26
 *  Modified : 1999/11/11
 *  
 *  Purpose  : Common solve generator for Fortran77 
 *  
 *             copyright();
 *             comment();
 *             timestamp();
 *             
 *            ** Memory allocation code generator **           
 *             mallocF77();
 *             mallocF77imode();
 *             mallocF77check();
 */

#include <iostream.h>
#include "feelfuncs.hpp"
#include "feeldef.hpp"
#include "Fortran77Generator.hpp"

Fortran77Generator::Fortran77Generator()      // constructor
{
  pushFlag = 0;
  srcPtr=srcBUF;
  return;
}

Fortran77Generator::~Fortran77Generator()    // destructor
{
  return;
}

void Fortran77Generator::Fortran77GeneratorSetFP(FILE *f )
{
  fp = f;
  return;
}

void Fortran77Generator::writeSource(const char *str)
{
  pushSource(str);
  flushSource();

  return;
}

void Fortran77Generator::wrtDEBUGcode(const char *str)
{
  extern int wrtDEBUGcodeFlag;
  if(wrtDEBUGcodeFlag == YES) writeSourceRAW(str);
  return;
}


void Fortran77Generator::writeSourceRAW(const char *str)
{
  fprintf(fp,"%s\n",str);

  return;
}


void Fortran77Generator::pushSource(const char *str)   // str memory cannot be maintained.
{
  int len;
  len = stringLength(str);

  if(pushFlag + len > BUFSIZ) {
    cerr << "pushSource string too long.\n";
    abortExit(1);
  }
  
  sprintf(srcPtr,"%s%c",str,'\0');
  srcPtr   = srcPtr+len;
  pushFlag = pushFlag + len;
  
  return;
}

void Fortran77Generator::pushSourceInt(const int dat)   // str memory cannot be maintained.
{
  char buf[BUFSIZ];
  sprintf(buf,"%d%c",dat,'\0');
  
  pushSource(buf);
  
  return;
}

void Fortran77Generator::flushSource(void)
{
  char f77buf[73];
  srcPtr = srcBUF;

  if(*srcBUF == '*' ||     // if comment, do nothing
     *srcBUF == 'c' ||
     *srcBUF == 'C'    ) {
    fprintf(fp,"%s\n",srcBUF);
    return;
  }


  // first line
  if(stringLength(srcPtr) > 72) {
    for(int i=0;i<72;i++) {
      f77buf[i] = *srcPtr;
      srcPtr++;
    }
    f77buf[72] = '\0';
    fprintf(fp,"%s\n",f77buf);
  }
  else {
    fprintf(fp,"%s\n",srcPtr);
    srcPtr += stringLength(srcPtr);
  }
  
  while(stringLength(srcPtr) > 0) {
    int columns;
    if(stringLength(srcPtr) > 72-7) {
      columns = 72-7;
    }
    else {
      columns = stringLength(srcPtr);
    }
    sprintf(f77buf,"%s","     $ ");
    for(int i=0;i<columns;i++) {
      f77buf[i+7] = *srcPtr;
      srcPtr++;
    }
    f77buf[columns+7] = 0;
    cerr << "stringLength(f77buf) = " <<stringLength(f77buf) << "\n";
    fprintf(fp,"%s\n",f77buf);
  }

  pushFlag = 0;
  srcPtr = srcBUF;
  return;
}

void Fortran77Generator::copyright(void) 
{
  writeSource("*------------------------------------------------------------");
  writeSource("* Generated by feelfem Copyright(c) 1999-2001 NEC Corporation");
  writeSource("*------------------------------------------------------------");
  return;
}

void Fortran77Generator::timestamp(void) 
{
  char buf[80];
  sprintf(buf,"* %s",getdate());
  writeSource(buf);
  writeSource("*----------------------------------------------------");
  
  return;
}  

void Fortran77Generator::fortImplicit(void) 
{
  writeSource("      implicit real*8(a-h,o-z)");
  
  return;
}


void Fortran77Generator::comment(void) 
{
  writeSource("*------------------------------------------------------------");
  return;
}

void Fortran77Generator::com(void) 
{
  writeSource("*");
  return;
}

void Fortran77Generator::COMMENTlong(char *com)
{
  char buf[BUFSIZ];
  writeSource("*-----");
  sprintf(buf,"* %s",com);
  writeSource(buf);
  writeSource("*-------------------------------------");
  
  return;
}

/*---------------------------------------
 * Memory allocation f_alloc function
 *---------------------------------------*/
void Fortran77Generator::mallocF77(char *varname,
				  char *comment,
				  char *size,
				  char *type     )
{
  char buf[BUFSIZ];
  sprintf(buf,"      call f_alloc(%s,'%s',%s,%s,0)",    // last 0 is imode
	  varname,comment,size,type);
  writeSource(buf);

  return;
}

void Fortran77Generator::mallocF77imode(char *varname,
				       char *comment,
				       char *size,
				       char *type)
{
  char buf[BUFSIZ];

  writeSource("      imode = -1");

  sprintf(buf,"      call f_alloc(%s,'%s',%s,%s,imode)",varname,
	                                                   comment,size,type);
  writeSource(buf);

  return;
}


void Fortran77Generator::mallocF77check(void) 
{
  writeSource("      if(imode .ne. 0) return");

  return;
}
