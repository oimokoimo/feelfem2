module mod_elem1
contains

subroutine elem1(mypeid,nprocs,isumup, &
                 enptr,con,nelem,      &
                 x,y,ipf,ipd,npmax,    &
                 enptr_ex,con_ex,nelem_ex, &
                 ndno,peno,x_ex,y_ex,ipf_ex,ipd_ex,nouter  &
     ,fem_v,fem_v_ex,valmat,vfg,indrow,iptrcol,neq,ipd_halo,nhalo,ncof)
!--------------------------------------------------------
! Generated by  feelfem Copyright(c) 2000 NEC Corporation
!--------------------------------------------------------
! feelfem90/DRAMA Program Model
! 2001/05/08 11:01
!----------------------------------------------------
use subSolveDrama
! general modules
use preport90
use numeric
use abortmodule
implicit none
integer,intent(in)                :: mypeid,nprocs
integer,dimension(nprocs)         :: isumup
integer,dimension(:,:),pointer    :: enptr,con
integer,intent(in)                :: nelem
real(kind=REAL8),dimension(:),pointer :: x,y
integer,dimension(:),pointer      :: ipf,ipd
integer,intent(in)                :: npmax
integer,intent(in)                :: neq
integer,dimension(:,:),pointer    :: enptr_ex,con_ex
integer,intent(in)                :: nelem_ex
integer,intent(in)                :: nouter
integer,dimension(nouter),pointer :: ndno,peno,ipf_ex,ipd_ex
real(kind=REAL8),dimension(:),pointer :: x_ex,y_ex

real(kind=REAL8),dimension(:),pointer :: fem_v
real(kind=REAL8),dimension(:),pointer :: fem_v_ex

integer                                  :: nhalo
integer,dimension(:),pointer             :: ipd_halo
real   (kind=REAL8),dimension(:),pointer :: valmat,vfg
integer,dimension(:)            ,pointer :: indrow,iptrcol
integer                                  :: ncof
!------------------------------------------------------
! Problem dependent parameters
!------------------------------------------------------
integer,parameter       :: NDF = 3
integer,parameter       :: NDP = 3
integer,parameter       :: NPG1 =  6  ! No.1 [tri4]
!------------------------------------------------------
!------------------------------------------------------
! Auto variables
!------------------------------------------------------
integer                           :: i,j,k,l
integer                           :: ip,jp
integer                           :: ind,ipe
integer                           :: nd
integer                           :: iptf,iptt
integer                           :: ipos_from,ipos_to
integer                           :: ietype
integer                           :: nodes
real(kind=REAL8),dimension(NDP) :: ex,ey
real(kind=REAL8),dimension(NDP) :: efem_v

integer,dimension(NDF)   :: ienp,iedp,ikp,jkp
real(kind=REAL8)         :: ea,eb
!------------------------------------------------------
common /em1_1/ ea(NDF,NDF),eb(NDF)
!------------------------------------------------------
data ienp/1,2,3/
data iedp/0,0,0/
!------------------------------------------------------
call eset1_1_1
!------------------------------------------------------
!------------------------------------------------------
! Own enptr loop
!------------------------------------------------------
do 100 i=1,nelem
ipos_from = enptr(1,i  )
ipos_to   = enptr(1,i+1)-1
ietype    = enptr(2,i  )
nodes     = ipos_to-ipos_from+1

!**** if(ietype .EQ. 1) then
  do j=1,nodes
   jp=j-1+ipos_from
   if(con(2,jp) .eq. mypeid) then
     ex(j)=x(con(1,jp))
     ey(j)=y(con(1,jp))
     efem_v(j)=fem_v(con(1,jp))
   else
     nd = ndsearch_ex(con(1,jp),con(2,jp),ndno,peno,nouter)
     ex(j) = x_ex(nd)
     ey(j) = y_ex(nd)
     efem_v(j)=fem_v_ex(nd)
   endif
  end do

  call ecal1_1(ex(1),ey(1),ex(2),ey(2),ex(3),ey(3),efem_v(1),efem_v(2),efem_v(3))

 do j=1,NDF
  jp   = ienp(j)+ipos_from-1
  ind  = con(1,jp)
  ipe  = con(2,jp)
  if(ipe == mypeid) then
   ikp(j) = ipd(ind)+iedp(j)
   jkp(j) = ikp(j)                                ! AMG/CRS
  else
   nd = ndsearch_ex(ind,ipe,ndno,peno,nouter)
   ikp(j) = 0
   jkp(j) = ipd_halo(nd)+iedp(j)+neq ! AMG/CRS
  endif
 end do

  do 1015 j=1,NDF
   ip = ikp(j)
   if(ip .eq. 0) goto 1015

   iptf = iptrcol(ip)
   iptt = iptrcol(ip+1)-1
   do 1016 k=1,NDF
     jp = jkp(k)
     do 1017 L=iptf,iptt
       if(indrow(L) .eq. jp) goto 1018
 1017 continue
!--- err
                  write(*,*) '??? ',ip,jp,'(',mypeid,')'
                  call abortexit(mypeid)
!--- err
 1018           continue
          valmat(L) = valmat(L)+ea(j,k)
 1016  continue
 1015 continue

   do 1019 j=1,NDF
     if(ikp(j) .eq. 0) goto 1019
     vfg(ikp(j)) = vfg(ikp(j)) + eb(j)
 1019   continue
!****      endif
 100  continue
!---           end of my enptr loop

!------------------------------------------------------
! External enptr_ex loop
!------------------------------------------------------
      do 200 i=1,nelem_ex
ipos_from = enptr_ex(1,i  )
ipos_to   = enptr_ex(1,i+1)-1
ietype    = enptr_ex(2,i  )
nodes     = ipos_to-ipos_from+1

!**** if(ietype .EQ. 1) then
  do j=1,nodes
   jp=j-1+ipos_from
   if(con_ex(2,jp) .eq. mypeid) then
     ex(j)=x(con_ex(1,jp))
     ey(j)=y(con_ex(1,jp))
     efem_v(j)=fem_v(con_ex(1,jp))
   else
     nd = ndsearch_ex(con_ex(1,jp),con_ex(2,jp),ndno,peno,nouter)
     ex(j) = x_ex(nd)
     ey(j) = y_ex(nd)
     efem_v(j)=fem_v_ex(nd)
   endif
  end do

  call ecal1_1(ex(1),ey(1),ex(2),ey(2),ex(3),ey(3),efem_v(1),efem_v(2),efem_v(3))

 do j=1,NDF
  jp   = ienp(j)+ipos_from-1
  ind  = con_ex(1,jp)
  ipe  = con_ex(2,jp)
  if(ipe == mypeid) then
   ikp(j) = ipd(ind)+iedp(j)
   jkp(j) = ikp(j)                                ! AMG/CRS
  else
   nd = ndsearch_ex(ind,ipe,ndno,peno,nouter)
   ikp(j) = 0
   jkp(j) = ipd_halo(nd)+iedp(j)+neq              ! AMG/CRS
  endif
 end do

   do 2015 j=1,NDF
     ip = ikp(j)
     if(ip .eq. 0) goto 2015

     iptf = iptrcol(ip)
     iptt = iptrcol(ip+1)-1
     do 2016 k=1,NDF
       jp = jkp(k)
       do 2017 L=iptf,iptt
       if(indrow(L) .eq. jp) goto 2018
 2017 continue
!--- err
                  write(*,*) 'in ex',ip,jp,'(',mypeid,')'
                  call abortexit(mypeid)
!--- err
 2018   continue
        valmat(L) = valmat(L)+ea(j,k)
 2016  continue
 2015 continue

   do 2019 j=1,NDF
       if(ikp(j) .eq. 0) goto 2019
       vfg(ikp(j)) = vfg(ikp(j)) + eb(j)
 2019 continue
!----
!****     endif
 200  continue
!---           end of external enptr loop
!------------------------------------------------------
end subroutine elem1
end module mod_elem1
