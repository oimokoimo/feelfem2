module mod_solve1
contains

subroutine solve1(myrank,nprocs,mypeid, &
   npmax,x,y,                          &
   firstDramaEdatPtr,firstDramaNsetPtr &
,fem_u,fem_v)
!--------------------------------------------------------
! Generated by  feelfem Copyright(c) 2000 NEC Corporation
!--------------------------------------------------------
! feelfem90/DRAMA Program Model
! 2001/05/08 11:01
!----------------------------------------------------
! AMG solver related modules
use mod_amg_penv
use mod_amg_update
use mod_amg_initialize
use mod_amg_amg2r5wf90

use mod_pamg81param1_1
! Matrix data structure related modules
use PAMGCRS

! modules for solve
use subSolveDrama
use femDataType
use dramaDataModel

! general modules
use preport90
use numeric
use abortmodule

! solve family
use mod_elem1
use mod_mksolve1extdata
use mod_dcond1_1
use mod_edev1_1

implicit none

integer(kind=INT4 )                  :: myrank,nprocs,mypeid
integer(kind=INT4 )                  :: npmax
real   (kind=REAL8),dimension(:),pointer :: x,y
type (dramaEdatList),pointer         :: firstDramaEdatPtr
type (dramaNsetList),pointer         :: firstDramaNsetPtr

real(kind=REAL8),dimension(:),pointer :: fem_u
real(kind=REAL8),dimension(:),pointer :: fem_v

!------------------------------------------------------
! Problem dependent variables
!------------------------------------------------------
integer,parameter         :: neg = 1
integer,parameter         :: maxElementNodes = 3
integer,parameter         :: dirichletSets =1
integer,parameter         :: neumannSets =0
!------------------------------------------------------
!------------------------------------------------------
! auto variables
!------------------------------------------------------
integer(kind=INT4 )                        :: i,j
integer(kind=INT4 )                        :: ierror
integer(kind=INT4 )                        :: nelem
integer(kind=INT4 ),dimension(:,:),pointer :: enptr,con
integer(kind=INT4 ),dimension(:)  ,pointer :: matno

integer,dimension(:),pointer               :: ipd,ipf
integer                                    :: neq
integer,dimension(:),pointer               :: isumup

integer                                    :: nelem_ex,nouter
integer,dimension(:,:),pointer             :: enptr_ex,con_ex
integer,dimension(:),pointer               :: matno_ex
integer,dimension(:),pointer               :: ndno,peno
integer,dimension(:),pointer               :: ipf_ex,ipd_ex

real(kind=REAL8),dimension(:),pointer :: x_ex,y_ex
real(kind=REAL8),dimension(:),pointer :: fem_u_ex
real(kind=REAL8),dimension(:),pointer :: fem_v_ex
!------------------------------------------------------
! Problem dependent parameters
!------------------------------------------------------
integer                        :: edatno
integer                        :: nenfre(maxElementNodes,neg)
integer                        :: nsetno(dirichletSets)
! integer                        :: nbedtno(neumannSets)
!------------------------------------------------
!  Element equation topology variable
!------------------------------------------------
integer                        :: ncmax         ! maximum number of elements
                                                ! connecting one node

integer                        :: ndfmax        ! maximum freedom for
                                                ! one element

integer                        :: nenfremax     ! maximum freedom per one node
                                                ! for each element

integer                        :: ncon          ! maximum freedom per one node
                                                ! including connecting elements
!------------------------------------------------------
! Matrix related variables
!------------------------------------------------------
integer                                  :: nhalo
integer,dimension(:),pointer             :: ipd_halo
real   (kind=REAL8),dimension(:),pointer :: valmat,vfg
integer,dimension(:)            ,pointer :: indrow,iptrcol
integer,dimension(:),pointer             :: sort_ex
integer                                  :: ncof

type (amg_penv),       pointer :: penv
type (amg_update_info),pointer :: pupdate
type (amg_global_info),pointer :: glinfo

!------------------------------------------------------
! Solver Library dependent variables
!------------------------------------------------------
real(kind=REAL8),dimension(:),pointer :: resvec
integer                        :: matrix
integer                        :: iswtch
integer                        :: iout
integer                        :: iprint
integer                        :: levelx
integer                        :: ifirst
integer                        :: ncyc
real(kind=REAL8 )              :: epsamg
integer                        :: madapt
integer                        :: nrd
integer                        :: nsolco
integer                        :: nru
real(kind=REAL8 )              :: ecg1,ecg2 
real(kind=REAL8 )              :: ewt2 
integer                        :: nwt
integer                        :: ntr
integer                        :: ncoarsen
integer                        :: icopy
integer                        :: iflag
real                           :: time(maxgrid)

integer,dimension(:),pointer   :: iuamg,ipamg,iscale
integer                        :: nsys,npts

!------------------------------------------------------
! Problem parameters
!------------------------------------------------------
data edatno/1/
data nenfre/1,1,1/
data nsetno/1/

!------------------------------------------------------
!  allocate enptr,con,matno in the next subroutine
!------------------------------------------------------
call setdramaedat(edatno,firstDramaEdatPtr,nelem,enptr,con,matno)
if(myrank == 0) call preport('SOLVE 1 START')
!------------------------------------------------------
!  Construct ipf,ipd
!------------------------------------------------------
allocate(ipf(npmax))
allocate(ipd(npmax))

call zeroi(ipd,npmax)
call zeroi(ipf,npmax)

call makeipfdrama(mypeid,nenfre,maxElementNodes,neg, &
                  enptr,con,nelem,npmax,ipf          )

call makeipddrama(ipf,ipd,npmax,neq)

if(myrank == 0) call preportmodule('makeipfdrama,makeipddrama')

!------------------------------------------------------
! Make external exptr/external node information
!------------------------------------------------------
call mksolve1extdata(myrank,nprocs,mypeid,            &
                  enptr,con,matno,nelem,                &
                  ipf,ipd,npmax,                        &
                  neq,                                  &
                  isumup,                               &
                  nelem_ex,enptr_ex,con_ex,matno_ex,    &
                  nouter,ndno,peno,ipf_ex,ipd_ex,       &
                 x,y,x_ex,y_ex,fem_v,fem_v_ex)
if(myrank.eq.0) call preportmodule('mksolve1extdata')

!------------------------------------------------------
! Boundary Data is prepared before solve 1
! in DRAMA MPI parallel version.
!------------------------------------------------------
!------------------------------------------------------
! Calculate maxmal number of element connection to one node
!------------------------------------------------------
call pnc_connect90(mypeid,npmax,enptr   ,con   ,nelem   , &
                                enptr_ex,con_ex,nelem_ex, &
                                ncmax                     )

if(myrank == 0) call preportmodule('PNC_CONNECT90')

!------------------------------------------------------
! Make distributed AMG-CRS array
!------------------------------------------------------
nenfremax = 0
do i=1,neg
 do j=1,maxElementNodes
  if(nenfremax < nenfre(j,i)) nenfremax=nenfre(j,i)
 end do
end do

ndfmax = nenfremax * maxElementNodes
ncon   = nenfremax * maxElementNodes * ncmax

call pmkAMGCRShalo(nouter,ndno,peno,ipf_ex,ipd_ex, &
                   ipd_halo,sort_ex                )
if(myrank==0) call preportmodule('pmkAMGCRShalo')

call pmkAMGCRSindex(mypeid,nprocs,            &
                    neq,isumup,               &
                    ndfmax,ncon,              &
                    ipf,ipd,npmax,            &
                    ndno,peno,nouter,         &
                    ipf_ex,ipd_ex,ipd_halo,   &
                    enptr,con,nelem,          &
                    enptr_ex,con_ex,nelem_ex, &
                    iptrcol,indrow,ncof,nhalo )

if(myrank == 0) call preportmodule('pmkAMGCRSindex')

!------------------------------------------------------
! Allocate matrix, right hand side
!------------------------------------------------------
allocate(valmat(ncof))
allocate(vfg(neq))
call zerod(valmat,ncof)
call zerod(vfg,neq)

!------------------------------------------------------
!  Assemble routine call
!------------------------------------------------------
call elem1(mypeid,nprocs,isumup,               &
      enptr,con,nelem,                         &
      x,y,ipf,ipd,npmax,                       &
      enptr_ex,con_ex,nelem_ex,                &
      ndno,peno,x_ex,y_ex,ipf_ex,ipd_ex,nouter &
     ,fem_v,fem_v_ex,valmat,vfg,indrow,iptrcol,neq,ipd_halo,nhalo,ncof)

if(myrank == 0) call preport('solve1 : Assemble routine')
!------------------------------------------------------
! No Neumann Condition
!------------------------------------------------------
if(myrank == 0) call preport('solve1 : Neumann routine')
!------------------------------------------------------
! Dirichlet Conditions
!------------------------------------------------------
! No.1
call dcond1_1(mypeid,nprocs,                       &
       nsetno(1),firstDramaNsetPtr,                &
       isumup,                                     &
       enptr,con,nelem,                            &
       x,y,ipf,ipd,npmax,                          &
       enptr_ex,con_ex,nelem_ex,                   &
       ndno,peno,x_ex,y_ex,ipf_ex,ipd_ex,nouter    &
       ,valmat,vfg,indrow,iptrcol,neq,ipd_halo,nhalo)

if(myrank == 0) call preport('solve1 : Dirichlet routine')
!------------------------------------------------------
! make amg information
!------------------------------------------------------
call amg_initialize()

!call initcommon()
!call amg_alloc_clearcounters()

call pmkAMGCRSupdate(myrank,nprocs,mypeid,           &
                     neq,nhalo,isumup,               &
                     ndno,peno,nouter,               &
                     ipf_ex,ipd_ex,ipd_halo,sort_ex, &
                     iptrcol,indrow,ncof,            &
                     penv,pupdate,glinfo             )

if(myrank.eq.0) call preportmodule('pmkAMGCRSupdate')

!------------------------------------------------------
! Allocate solution vector
!------------------------------------------------------
allocate( resvec(neq + nhalo))
call zerod(resvec,neq+nhalo)

!------------------------------------------------------
! PAMG parameters
!------------------------------------------------------
matrix    =  12     !(matrix type  1: symmetric  2: not symmetric)

iswtch    =  4      !(setup->first->solve->wrkcnt, each entry is 4,3,2,1)
                    !( in this case 4 ?)

iout      =  14     !( 0:no output,1: residual 2:statistics cp-times,etc.
                    !  3:residual at each amg-cycle   4: alles           )

iprint    = 10606   ! 1st digit: not used; has to be non-zero
                    ! 2nd and 3rd digit  --  iup: unit number for results
                    ! 4th and 5th digit  --  ium: unit number for messages  

levelx    = 25      ! maximum number of mg-levels to be created

ifirst    = 13      ! parameter for first approximation
                    ! 1st digit of ifirst: not used; has to be non-zero. 
                    ! 2nd digit of ifirst  --  itypu:
                    ! =0: no setting of first approximation,
                    ! =1: first approximation constant to zero,
                    ! =2: first approximation constant to one,
                    ! =3: first approximation is random function with
                    !     the concrete random sequence being determined
                    !     by the follwing digits.         

ncyc      = 125100  ! integer parameter describing the type of cycle to be
                    ! used and the number of cycles to be performed.
                    ! 1st digit of ncyc  --  igam:
                    ! =1: v -cycle,
                    ! =2: v*-cycle,
                    ! =3: f -cycle,
                    ! =4: w -cycle.
                    ! if ncyc is negativ, then the approximation of the
                    ! problem on the second finest grid is computed by
                    ! igam v-cycles on that particular grid.
                    !
                    ! 2nd digit of ncyc  --  icgr:
                    ! =0: no conjugate gradient,
                    ! =1: conjugate gradient (only first step of cg),
                    ! =2: conjugate gradient (full cg).
                    !
                    ! 3rd digit of ncyc  --  iconv:
                    ! convergence criterion for the user-defined problem
                    ! (finest grid):
                    ! =1: perform a fixed number of cycles as given by
                    !    ncycle (see below)
                    ! =2: stop, if  ||res|| < eps
                    ! =3: stop, if  ||res|| < eps * |f|
                    ! =4: stop, if  ||res|| < eps * |u| * |diag|
                    ! with ||res|| = l2-norm of residual,
                    !      eps     (see input parameter eps)
                    !      |f|   = supremum norm of right hand side
                    !      |u|   = supremum norm of solution
                    !     |diag|  = maximal diagonal entry in matrix l
                    ! note that in any case the solution process stops
                    ! after at most ncycle cycles.       

epsamg    = 1.0d-9  ! convergence criterion for solution process: (see
                    ! parameter ncyc). note that no more than ncycle cycles
                    ! are performed, regardless of eps.     

madapt    = 1       ! integer value specifying the choice of coarsest
                    ! grid in cycling:
                    ! 1st digit of madapt  --  msel:
                    ! =1: in cycling, all grids constructed in the setup
                    !     phase are used without check.
                    ! =2: the number of grids is automatically reduced
                    !     if the convergence factor on the coarser grids
                    !     is found to be larger than a given value fac
                    !     (see below).
                    !
                    ! rest of madapt  --  fac
                    !    the rest of madapt defines the fractional part
                    !    of a real number fac between 0.1 and 0.99, e.g.
                    !    madapt=258 means msel=2 and fac=0.58. if madapt
                    !    consists of only one digit, fac is set to 0.7
                    !    by default.  

nrd       =  1231   !  parameter describing relaxation (downwards):
                    ! 1st digit of nrd: not used; has to be non-zero.
                    ! 2nd digit of nrd  --  nrdx:
                    !     actual number of smoothing steps to be performed
                    !     the type of which is given by the following digits
                    ! following digits  --  array nrdtyp:
                    ! =1: relaxation over the f-points only
                    ! =2: full gs sweep
                    ! =3: relaxation over the c-points only
                    ! =4: full more color sweep, highest color first      

nsolco    =   2     ! parameter controlling the solution on coarsest grid:
                    ! 1st digit  --  nsc:
                    !  =1: gauss-seidel method
                    !  =2: direct solver (YALE,ESSL or ESSL substitute)
                    !      plug in IESSL or IYALE in the subroutine
                    !      amg_strin_inp to choose the YALE sparse matrix
                    !      direct solver or plug in IESSL for the ESSL
                    !      direct solver for full
                    !      nonsymmetric rectangular matrices. In case
                    !      the ESSL solver is not installed on your machine
                    !      you still may use the parameter IESSL if the
                    !      substitutes for ESSL in amgesslsub.F has been
                    !      installed by avoiding the pre-compiler directive
                    !      -DESSL
                    !      (Usually its a better to choose IESSL
                    !       as the coarse grid matrices tend to be full)
                    !
                    ! rest of nsolco  --  nrcx: (only if nsc=1)
                    ! number of gs sweeps on coarsest grid (>=0).
                    ! if nrcx=0, then as many gs sweeps are performed
                    ! as are needed to reduce the residual by two orders
                    ! of magnitude. (maximal 100 relaxation sweeps)

nru       =   1231  ! parameter for relaxation (upwards), analogous to nrd.

! class 4 parameters 
ecg1      =  0.     ! real parameters affecting the creation of coarser
ecg2      =  0.25   ! real parameters affecting the creation of coarser

ewt2      =  0.35   ! grids and/or the definition of the interpolation.
                    ! the choice of these parameters depends on
                    ! the actual amg version (see subroutine crsng) 

nwt       =  14     ! integer parameter affecting the creation of coarser
                    ! grids and/or the definition of the interpolation.
                    ! the choice of this parameter depends on
                    ! the actual amg version (see subroutine crsng)

ntr       =  0      ! parameter controlling coarse-grid operator truncation
                    ! =0: pairs of zeroes are removed from coarse grid
                    !     operators
                    ! =1: no coarse-grid operator truncation
                    ! (there should be enough memory location contained in a
                    !  ja if zeros need to be inserted !)    

ncoarsen  = 0
icopy     = 0
iflag     = 1
!time
!iunit_amg =14

!------------------------------------------------------
! Version 8.1 additional parameters
!------------------------------------------------------
call pamg81param1_1(mypeid,nprocs,isumup,      &
      enptr,con,nelem,                         &
      ipf,ipd,npmax,                           &
      enptr_ex,con_ex,nelem_ex,                &
      ndno,peno,ipf_ex,ipd_ex,nouter,          &
      neq,ipd_halo,nhalo,                      &
      iuamg,ipamg,nsys,npts,iscale             ) ! set here

call amg2r5wf90(valmat,iptrcol,indrow,resvec,vfg,ncof,neq,nhalo, &
                iuamg,ipamg,nsys,npts,iscale,                    &
                penv,pupdate,glinfo,                             &
                matrix,iswtch,iout,iprint,                       &
                levelx,ifirst,ncyc,epsamg,madapt,nrd,nsolco,nru, &
                ecg1,ecg2,ewt2,nwt,ntr,ncoarsen,                 &
                icopy,iflag,time,iunit_amg,ierror                )

      if(myrank.eq.0) call preportmodule('PAMG solve No.1 Finished')
!------------------------------------------------------

if(myrank == 0) call preport('solve1 : Solver routine')
!------------------------------------------------------
! Call Edev Routine
!------------------------------------------------------
call edev1_1(mypeid,resvec,ipd, &
  enptr,con,nelem,fem_u)
!------------------------------------------------------
deallocate(indrow,iptrcol)
deallocate(valmat,vfg)  
deallocate(resvec)

end subroutine solve1
end module mod_solve1
