      subroutine solve1(feel,myrank,nprocs,ndim,
     $   npmax,x,y,
     $   redatinfo,enptrlst,matnolst,conlst,
     $   nbedat,nbnset, inbctr2,idbctr2
     &,fem_u,fem_v)
*------------------------------------------------------------
* Generated by feelfem Copyright(c) 1999-2001 NEC Corporation
*------------------------------------------------------------
* FEEL P2/DRAMA Program Model
* 2001/11/14 11:11
*----------------------------------------------------
      implicit real*8(a-h,o-z)
*------------------------------------------------------------
      include 'mpif.h'
      real*4 feel(*)
*
      real*8 x(*),y(*)
      integer*4 myrank,nprocs,ndim
      integer*4 npmax
*
      dimension fem_u(*)
      dimension fem_v(*)
*
      integer*4 redatinfo(3,*)
      integer*4 enptrlst(*),conlst(*)
      integer*4 matnolst(*)
      integer*4 nbedat,nbnset
      integer*4 inbctr2(5,*)
      integer*4 idbctr2(5,*)
*
      parameter (MAX_PROCS   = 256)
      parameter (NBYTE_REAL8 =   2)
      parameter (NCTRL_ITEMS =   4)
*
*------------------------------------------------------------
      parameter (NEG = 1)
      parameter (MAX_ELEMENT_NODES=3)
      parameter (NDC = 1)
      parameter (NNC = 0)
*------------------------------------------------------------
      integer*4 edatno
      dimension nenfre(MAX_ELEMENT_NODES,NEG)
      dimension nsetno(NDC)
*------------------------------------------------------------
      data edatno/1/
      data nenfre/1,1,1/
      data nsetno/1/
*------------------------------------------------------------
      if(nprocs .GT. MAX_PROCS) then
        call abortexit(myrank,'Too many nprocs in solve')
      endif
*
      call f_alloc_push
*
      mypeid = myrank
      mypeidx= myrank+1
*
      nelem = redatinfo(2,edatno)
      if(redatinfo(1,edatno) .ne. edatno) call abortexit(myrank,'redatin
     $ fo ERR')
      if(redatinfo(3,edatno) .NE. nelem*MAX_ELEMENT_NODES) then
        call abortexit(myrank,'Mismatch redatinfo/MAX_ELEMENT_NODES')
      endif
*
      np_e = enptrlst(edatno)
      np_m = matnolst(edatno)
      np_c = conlst  (edatno)
*
      if(myrank.eq. 0) then
        call preport('SOLVE 1 START')
      endif
*-----
* IPD (node-wise equation number::DRAMA double index)
*-------------------------------------
      call f_alloc(np_IPD,'(IPD)',npmax,0,0)
*-----
* IPF (node-wise freedom)
*-------------------------------------
      call f_alloc(np_IPF,'(IPF)',npmax,0,0)
      call zeroi(feel(np_IPD),npmax)
      call zeroi(feel(np_IPF),npmax)
*
      call makeipfex(mypeid,nenfre,MAX_ELEMENT_NODES,NEG,
     $     feel(np_e),feel(np_c),nelem,npmax,feel(np_ipf))
      ndfmax = MAX_ELEMENT_NODES
*
      call makeipdex(feel(np_ipf),feel(np_ipd),npmax,neq)
*------------------------------------------------------------
* Make exchange list (eflag/nflag)
*------------------------------------------------------------
      call f_alloc(np_eflag,'element flag',nelem,0,0)
      call f_alloc(np_nflag,'element flag',npmax,0,0)
      call mksendlst(feel,myrank,nprocs,
     $ feel(np_e),feel(np_c),nelem,npmax,
     $ feel(np_eflag),feel(np_nflag),
     $ ne2send,nconsiz,nn2send)
*
      if(myrank .eq. 0) call preportmodule('MKSENDLST')
*------------------------------------------------------------
* Calculation of necessary memory size
*
*  INTEGER*4 data buffer
* -------
*  ctrl    INTEGER*4     NCTRL_ITEMS
* -------
*  enptr   INTEGER*4   2*ne2send
*  con     INTEGER*4   2*nconsiz
*  matno   INTEGER*4     ne2send
* -------
*  nodeno  INTEGER*4     nn2send
*  ipf     INTEGER*4     nn2send
*  ipd     INTEGER*4     nn2send
*-------------------------------
* REAL*8 data buffer
* x,y (,z) REAL*8   ndim*nn2send
* KNOWN FEM variables
* UNKNOWN FEM variables (nonlinear case)
*------------------------------------------------------------
      nsend_int  = NCTRL_ITEMS +
     $            (ne2send+1)*2 + ne2send+nconsiz*2+
     $             nn2send*3
*
*     nfemvars_send   number of fem variables to send
      nfemvars_send = 1
      nsend_dbl  = nn2send*ndim + nn2send*nfemvars_send
*
      call f_alloc(np_mysendibuf,'mysendifuf',nsend_int,0,0)
      if(nsend_dbl .NE. 0) then
        call f_alloc(np_mysenddbuf,'mysenddbuf',nsend_dbl,1,0)
      else
        np_mysenddbuf = 1
      endif
*
      np_ctrl_send  = np_mysendibuf
      np_enptr_send = np_mysendibuf+NCTRL_ITEMS
      np_con_send   = np_mysendibuf+NCTRL_ITEMS+(ne2send+1)*2
      np_matno_send = np_con_send  + nconsiz   *2
      np_nodeno_send= np_matno_send+ ne2send
      np_ipf_send   = np_nodeno_send+nn2send
      np_ipd_send   = np_ipf_send  + nn2send
      np_x_send     = np_mysenddbuf
      np_y_send     = np_mysenddbuf+nn2send*NBYTE_REAL8
      np_v_send = np_mysenddbuf+nn2send*NBYTE_REAL8*2
*------------------------------------------------------------
      call solve1mksdbuf(myrank,nprocs,npmax,nelem,
     $  ne2send,nconsiz,nn2send,neq,
     $  feel(np_e),feel(np_c),feel(np_m),
     $  feel(np_eflag),feel(np_nflag),
     $  x,y,feel(np_ipf),feel(np_ipd),fem_v,
     $  feel(np_ctrl_send),
     $  feel(np_enptr_send),feel(np_con_send),feel(np_matno_send),
     $  feel(np_nodeno_send),feel(np_ipf_send),feel(np_ipd_send),
     $  feel(np_x_send),feel(np_y_send),feel(np_v_send))
*
      if(myrank.eq.0) call preportmodule('DATSEND WRITE')
*------------------------------------------------------------
      call feelgathervbcast(myrank,nprocs,feel,
     $     nsend_int,feel(np_mysendibuf),
     $     np_intbuf,np_intcounts,np_intdispls)
*
      call feelgathervbcastdbl(myrank,nprocs,feel,
     $     nsend_dbl,feel(np_mysenddbuf),
     $     np_dblbuf,np_dblcounts,np_dbldispls)
*------------------------------------------------------------
*-----
* Make Exterior enptr/con
*-------------------------------------
      call mkielemex(feel,myrank,nprocs,NCTRL_ITEMS,
     $     feel(np_e),feel(np_c),feel(np_m),nelem,
     $     feel(np_intbuf),
     $     feel(np_intcounts),feel(np_intdispls),
     $     feel(np_dblbuf),
     $     feel(np_dblcounts),feel(np_dbldispls),
     $     nelem_ex,np_enptr_ex,np_con_ex,np_matno_ex)
      if(myrank.eq.0) call preportmodule('MKIELEMEX')
*------------------------------------------------------------
*-----
* Make NODE EX
*-------------------------------------
      call solve1mkexnode(feel,myrank,nprocs,NCTRL_ITEMS,
     $     x,y,npmax,
     $ fem_v,
     $  feel(np_e),feel(np_c),nelem,
     $  feel(np_enptr_ex),feel(np_con_ex),nelem_ex,
     $  feel(np_intbuf),
     $  feel(np_intcounts),feel(np_intdispls),
     $  feel(np_dblbuf),
     $  feel(np_dblcounts),feel(np_dbldispls),
     $  nouter,
     $  np_ndno,np_peno,np_ipfex,np_ipdex,np_xex,np_yex
     $  ,npfex_v)
      if(myrank.eq.0) call preportmodule('MAKEEXNODE')
*------------------------------------------------------------
*-----
* Make summed up degree of freedom
*-------------------------------------
      call f_alloc(np_isumup,'solve(isumup)',nprocs+1,0,0)
      call sumupdegree(mypeid,nprocs,NCTRL_ITEMS,
     $     feel(np_intbuf),
     $     feel(np_intcounts),feel(np_intdispls),
     $     feel(np_isumup),neqtotal,myeqfrom,myeqto)
      if(myrank.eq.0) call preportmodule('SUMUPDEGREE')
*------------------------------------------------------------
*------------------------------------------------------------
* Boundary Data is prepared before solve 1
* in DRAMA MPI parallel version.
*------------------------------------------------------------
*-----
* Matrix array allocation (Distributed CRS:Program Model FEELP2
*-------------------------------------
      call f_alloc_push
      call f_alloc(np_nc,'nc',npmax,0,0)
      call pnc_connect(mypeid,feel(np_nc),npmax,
     $                 feel(np_e),feel(np_c),nelem,
     $                 feel(np_enptr_ex),feel(np_con_ex),nelem_ex,
     $                 ncmax)
*
* clear np_nc
      call f_alloc_pop
*
      if(myrank.eq.0) call preportmodule('PNC_CONNECT')
*------------------------------------------------------------
* Make distributed CRS array
*
      nenfremax = 1
      do 15 j=1,NEG
      do 15 i=1,MAX_ELEMENT_NODES
       if(nenfremax .LT. nenfre(i,j)) nenfremax=nenfre(i,j)
 15   continue
*
      ncon = MAX_ELEMENT_NODES*NCMAX*nenfremax
      call f_alloc(np_IP,'SOLVE(IP)',neq+1,0,0)
      call f_alloc_push
      call f_alloc(np_IC,'solve(IC)',neq*ncon,0,0)
*
      call pmkCRSindex(mypeid,nprocs,ndfmax,
     $     feel(np_isumup),myeqfrom,myeqto,neqtotal,
     $     feel(np_e),feel(np_c),nelem,
     $     feel(np_ipf),feel(np_ipd),npmax,
     $     feel(np_enptr_ex),feel(np_con_ex),nelem_ex,
     $     feel(np_ndno),feel(np_peno),
     $     feel(np_ipfex),feel(np_ipdex),nouter,
     $     feel(np_IC),feel(np_IP),ncon,neq,
     $     feel(np_IC),
     $     ncof,maxnzpr)
*
      if(ncof .gt. ncon*neq) then
        call abortexit(myrank,'ncof>ncon*neq')
      endif
*
* memory move (actual movment done in pmkCRSindex)
      call f_alloc_pop
      call f_alloc(np_indrow,'INDROW',ncof,0,0)
      np_iptrcol = np_IP
*
      if(myrank.eq.0) call preportmodule('pmkCRSindes')
* allocation
      call f_alloc(np_valmat,'solve(valmat)',ncof,1,0)
      call f_alloc(np_vfg   ,'solve(vfg)',   neq ,1,0)
      call zerod(feel(np_valmat),ncof)
      call zerod(feel(np_vfg)   ,neq )
*------------------------------------------------------------
*------------------------------------------------------------
      call elem1(mypeid,nprocs,
     $   feel(np_isumup),myeqfrom,myeqto,neqtotal,
     $   feel(np_e),feel(np_c),nelem,
     $   x,y,feel(np_ipf),feel(np_ipd),npmax
     $   ,fem_v,
     $   feel(np_enptr_ex),feel(np_con_ex),nelem_ex,
     $   nouter,feel(np_ndno),feel(np_peno),
     $   feel(np_xex),feel(np_yex),feel(np_ipfex),feel(np_ipdex),
     $   feel(npfex_v),feel(np_VALMAT),feel(np_VFG),feel(np_INDROW),feel
     $ (np_IPTRCOL),neq,ncof)
      if(myrank .EQ. 0) then
      call preport('solve1 : Assemble routine')
      endif
*-----
* No Neumann Condition
*-------------------------------------
      if(myrank .EQ. 0) then
      call preport('solve1 : Neumann routine')
      endif
*-----
* Dirichlet Conditions
*-------------------------------------
      nbdno = nsetno(1)
      call dcond1_1(mypeid,nprocs,
     $     idbctr2(1,nbdno),idbctr2(2,nbdno),
     $     idbctr2(3,nbdno),
     $     feel(idbctr2(4,nbdno)),
     $     feel(idbctr2(5,nbdno)),
     $     feel(np_isumup),myeqfrom,myeqto,neqtotal,
     $     feel(np_e),feel(np_c),nelem,
     $     x,y,
     $     feel(np_ipf),feel(np_ipd),npmax,
     $     feel(np_enptr_ex),feel(np_con_ex),nelem_ex,
     $     feel(np_ndno),feel(np_peno),
     $     feel(np_xex),feel(np_yex),
     $     feel(np_ipfex),feel(np_ipdex),nouter,
     $     feel(np_iptrcol),feel(np_indrow),
     $     feel(np_valmat),feel(np_vfg),neq,ncof
     $)
*------------------------------------------------------------
      if(myrank .EQ. 0) then
      call preport('solve1 : Dirichlet routine')
      endif
*=========================
* CALL AchimLoc SOLVER
*=========================
      call f_alloc(np_resvec,'resvec',neq,1,0)
      call zerod(feel(np_resvec),neq)
*
      nf_choicderhs = 1
      nf_outlev     = 1
      nf_indcmaac   = 0
      nf_solvstart  = 2
*
      call mpi_barrier(mpi_comm_world,ierr)
      call cg110loc_feel(feel,
     $     myrank,neq,ncof,feel(np_valmat),nf_indcmaac,
     $     feel(np_indrow),feel(np_iptrcol),feel(np_vfg),
     $     feel(np_resvec),
     $     nf_choicderhs,nf_solvstart,nf_outlev)
      if(myrank.eq.0) call preportmodule('CG110LOC solve No.1 Finished')
*------------------------------------------------------------
*
      if(myrank .EQ. 0) then
      call preport('solve1 : Solver routine')
      endif
*-----
* Call Edev Routine
*-------------------------------------
      call edev1_1(myrank,feel(np_resvec),feel(np_ipd),
     $      feel(np_e),feel(np_c),nelem
     $,fem_u)
*------------------------------------------------------------
      call f_alloc_pop
      return
      end
      call f_alloc_pop
      return
      end
