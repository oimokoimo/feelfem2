/*
 *  feelfem v1.0 NEC Corporation (C) 1999,2000,2001
 *                   Programmed  by  Hidehiro FUJIO
 *
 *  Filename : SL_probInfoDistribute.cpp
 *  Date     : 2003/03/02 20:50
 *  Purpose  : Library module generator
 *
 */
#include "SL_feelfem90DRAMA.hpp"

static int come_yet_probInfoDistribute = 0;


void SL_feelfem90DRAMA::SL_probInfoDistribute(int makeFlag)
{
  char *sourceName;

  if(come_yet_probInfoDistribute == 1)  return;
  else                  come_yet_probInfoDistribute = 1;

  sourceName = GetSourceName("probInfoDistribute");
  OpenSource(sourceName,makeFlag);

  // ORIGINAL SOURCE STARTS-----------------


  writeSource("module mod_probInfoDistribute");
  com();
  writeSource("! two distribute subroutines");
  com();
  writeSource("! matInitDistribute      material and initial value distribute");
  writeSource("! probInfoDistribute     mesh data information and solve information distribute");
  com();
  com();
  writeSource("contains");
  com();
  writeSource("subroutine matInitDistribute(myrank,nprocs,numData,matData)");
  writeSource("!--------------------------------------------------");
  writeSource("! Distribute meshDat and solveLst information");
  com();
  writeSource("! Date        : 2003/02/19");
  writeSource("! Programmer  : Hidehiro Fujio");
  writeSource("!--------------------------------------------------");
  writeSource("  use numeric");
  writeSource("  use femDataType");
  com();
  writeSource("  implicit none");
  com();
  writeSource("  include 'mpif.h'");
  com();
  writeSource("  integer                               :: myrank,nprocs");
  com();
  writeSource("  type(numdat),pointer                  :: numData");
  writeSource("  type(matDat),pointer                  :: matData");
  com();
  writeSource("  integer                               :: nnum");
  writeSource("  integer                               :: regions");
  com();
  com();
  writeSource("  integer                               :: i");
  writeSource("  integer                               :: onflag");
  writeSource("  integer,dimension(:),pointer          :: ibuf");
  writeSource("  real(kind=REAL8),dimension(:),pointer :: dbuf");
  com();
  writeSource("  integer                               :: ierr");
  com();
  writeSource("!---------------");
  writeSource("! for numDat");
  writeSource("!---------------");
  writeSource("  onflag = 0");
  com();
  writeSource("  if(myrank .eq. 0) then");
  writeSource("     if(associated(numData)) then");
  writeSource("        onflag = 1");
  writeSource("     end if");
  writeSource("  end if");
  com();
  writeSource("  call MPI_BCAST(onflag,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)");
  com();
  writeSource("  if(onflag .eq. 1) then   ! numData exists");
  com();
  writeSource("     if(myrank .eq. 0) then");
  writeSource("        nnum = numData\%numbers");
  writeSource("     end if");
  com();
  writeSource("     call MPI_BCAST(nnum,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)");
  com();
  writeSource("     if(myrank .eq. 0) then");
  writeSource("        dbuf =>numData\%dat");
  writeSource("     else");
  writeSource("        allocate(numData,dbuf(nnum))");
  writeSource("        numData\%numbers = nnum");
  writeSource("        numData\%dat     =>dbuf");
  writeSource("     end if");
  com();
  writeSource("     call MPI_BCAST(dbuf,nnum,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ierr)");
  com();
  writeSource("  end if");
  com();
  writeSource("!---------------");
  writeSource("! for matDat");
  writeSource("!---------------");
  writeSource("  onflag = 0");
  com();
  writeSource("  if(myrank .eq. 0) then");
  writeSource("     if(associated(matData)) then");
  writeSource("        onflag = 1");
  writeSource("     end if");
  writeSource("  end if");
  com();
  writeSource("  call MPI_BCAST(onflag,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)");
  com();
  writeSource("  if(onflag .eq. 1) then   ! matData exists");
  com();
  writeSource("     if(myrank .eq. 0) then");
  writeSource("        regions = matData\%regions");
  writeSource("     end if");
  com();
  writeSource("     call MPI_BCAST(regions,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)");
  com();
  writeSource("     if(myrank .eq. 0) then");
  writeSource("        ibuf =>matData\%regmat");
  writeSource("     else");
  writeSource("        allocate(matData,ibuf(regions))");
  writeSource("        matData\%regions = regions");
  writeSource("        matData\%regmat  =>ibuf");
  writeSource("     end if");
  com();
  writeSource("     call MPI_BCAST(ibuf,regions,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)");
  com();
  writeSource("  end if");
  com();
  writeSource("end subroutine matInitDistribute");
  com();
  writeSource("subroutine probInfoDistribute(myrank,nprocs,meshDat,solveLst)");
  com();
  writeSource("!--------------------------------------------------");
  writeSource("! Distribute meshDat and solveLst information");
  com();
  writeSource("! Date        : 2003/02/17,18");
  writeSource("! Programmer  : Hidehiro Fujio");
  writeSource("!--------------------------------------------------");
  com();
  writeSource("  use femDataType");
  com();
  writeSource("  implicit none");
  com();
  writeSource("  include 'mpif.h'");
  com();
  writeSource("  integer                        :: myrank,nprocs");
  com();
  writeSource("  type(meshInformation)          :: meshDat");
  writeSource("  type(solveList)                :: solveLst");
  com();
  writeSource("  ! Informations to transfer");
  com();
  writeSource("  type(solveInformation),pointer :: solveInfoPtr");
  writeSource("  type(solveInformation), &");
  writeSource("       dimension(:),pointer      :: solveDataList");
  com();
  writeSource("  integer                        :: medtNo       ! meshDat\%medtNo");
  writeSource("  integer                        :: mainEdatNo   ! meshDat\%mainEdatNo");
  writeSource("  integer                        :: regionEdats  ! mesh");
  writeSource("  integer                        :: nredat");
  writeSource("  integer                        :: nbedat");
  writeSource("  integer                        :: solves");
  writeSource("  integer                        :: solveNo,edatno,solveEdatNo,dconds,nconds");
  writeSource("  integer                        :: condNo,datasets");
  com();
  writeSource("  type(boundaryDataSet),dimension(:),pointer :: dlst");
  writeSource("  type(boundaryDataSet),dimension(:),pointer :: nlst");
  writeSource("  type(boundaryDataSet),pointer              :: bdsetPtr");
  com();
  writeSource("  ! auto variables");
  com();
  writeSource("  integer                        :: i,j");
  writeSource("  integer                        :: ierr");
  writeSource("  integer,dimension(:),pointer   :: ibuf");
  writeSource("  integer,dimension(:),pointer   :: isendbuf");
  writeSource("  integer,dimension(:),pointer   :: irecvbuf");
  com();
  writeSource("  !==========================================================");
  writeSource("  ! meshData scatter distribution");
  writeSource("  !==========================================================");
  com();
  writeSource("  if(myrank .EQ. 0) then");
  writeSource("     medtNo     = meshDat\%medtNo");
  writeSource("     mainEdatNo = meshDat\%mainEdatNo");
  writeSource("     nredat     = meshDat\%regionEdats");
  writeSource("     nbedat     = meshDat\%boundaryEdats");
  writeSource("  end if");
  com();
  writeSource("  call MPI_BCAST(medtNo,     1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)");
  writeSource("  call MPI_BCAST(mainEdatNo, 1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)");
  writeSource("  call MPI_BCAST(nredat    , 1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)");
  writeSource("  call MPI_BCAST(nbedat    , 1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)");
  com();
  writeSource("  if(myrank .NE. 0) then");
  writeSource("     meshDat\%medtNo        = medtNo");
  writeSource("     meshDat\%mainEdatNo    = mainEdatNo");
  writeSource("     meshDat\%regionEdats   = nredat");
  writeSource("     meshDat\%boundaryEdats = nbedat");
  writeSource("  end if");
  com();
  writeSource("  if(nredat .NE. 0) then");
  com();
  writeSource("     if(myrank .EQ. 0) then");
  writeSource("        ibuf => meshDat\%redatlist");
  writeSource("     else");
  writeSource("        allocate( ibuf(nredat) )");
  writeSource("     end if");
  com();
  writeSource("     call MPI_BCAST(ibuf,nredat,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)");
  com();
  writeSource("     if(myrank .NE. 0) then");
  writeSource("        meshDat\%redatlist => ibuf");
  writeSource("     end if");
  com();
  writeSource("  end if");
  com();
  com();
  writeSource("  if(nbedat .NE. 0) then");
  com();
  writeSource("     if(myrank .EQ. 0) then");
  writeSource("        ibuf => meshDat\%bedatlist");
  writeSource("     else");
  writeSource("        allocate( ibuf(nredat) )");
  writeSource("     end if");
  com();
  writeSource("     call MPI_BCAST(ibuf,nredat,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)");
  com();
  writeSource("     if(myrank .NE. 0) then");
  writeSource("        meshDat\%bedatlist => ibuf");
  writeSource("     end if");
  com();
  writeSource("  end if");
  com();
  com();
  writeSource("  !==========================================================");
  writeSource("  ! solve Data scatter distribution");
  writeSource("  !==========================================================");
  writeSource("  if(myrank .EQ. 0) then");
  writeSource("     solves = solveLst\%solves");
  writeSource("  end if");
  com();
  writeSource("  call MPI_BCAST(solves , 1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)");
  com();
  writeSource("  if(myrank .EQ. 0) then");
  writeSource("     solveDataList => solveLst\%solveDataList    ! myrank has already");
  writeSource("  else");
  writeSource("     solveLst\%solves = solves");
  writeSource("     allocate(solveDataList(solves))            ! others allocate");
  writeSource("     solveLst\%solveDataList => solveDataList");
  writeSource("  end if");
  com();
  writeSource("  ! scatter each solves");
  com();
  writeSource("  do i=1,solves");
  com();
  writeSource("     if(myrank .EQ. 0) then");
  com();
  writeSource("        solveInfoPtr =>solveDataList(i)");
  com();
  writeSource("        solveNo = solveInfoPtr\%solveNo");
  writeSource("        edatno  = solveInfoPtr\%edatNo");
  writeSource("        dconds  = solveInfoPtr\%dconds");
  writeSource("        nconds  = solveInfoPtr\%nconds");
  com();
  writeSource("     end if");
  com();
  writeSource("     call MPI_BCAST(solveNo,     1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)");
  writeSource("     call MPI_BCAST(edatno,      1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)");
  writeSource("     call MPI_BCAST(dconds,      1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)");
  writeSource("     call MPI_BCAST(nconds,      1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)");
  com();
  writeSource("     if(myrank .NE. 0) then");
  writeSource("        solveInfoPtr =>solveDataList(i)");
  com();
  writeSource("        solveInfoPtr\%solveNo =solveNo");
  writeSource("        solveInfoPtr\%edatNo = edatno");
  writeSource("        solveInfoPtr\%dconds = dconds");
  writeSource("        solveInfoPtr\%nconds = nconds");
  writeSource("     end if");
  com();
  writeSource("     !------------------------");
  writeSource("     ! dirichlet condition");
  writeSource("     !------------------------");
  writeSource("     if(dconds > 0) then");
  com();
  writeSource("        ! dlst is type(boundaryDataSet),dimension(:),pointer");
  writeSource("        if(myrank .EQ. 0) then");
  writeSource("           dlst => solveInfoPtr\%dlst");
  writeSource("        else");
  writeSource("           allocate(dlst(dconds))");
  writeSource("           solveInfoPtr\%dlst =>dlst");
  writeSource("        end if");
  com();
  writeSource("        do j=1,dconds");
  com();
  writeSource("           bdsetPtr => dlst(j)   ! bdsetPtr");
  com();
  writeSource("           if(myrank .EQ. 0) then");
  writeSource("              condNo   =  bdsetPtr\%condNo");
  writeSource("              datasets =  bdsetPtr\%nofsets");
  writeSource("           endif");
  com();
  writeSource("           call MPI_BCAST(condNo,   1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)");
  writeSource("           call MPI_BCAST(datasets, 1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)");
  com();
  writeSource("           if(myrank .EQ. 0) then");
  writeSource("              ibuf     => bdsetPtr\%datlist   ! size is datasets");
  writeSource("           else");
  writeSource("              allocate(ibuf(datasets))       ! size is datasets");
  writeSource("           end if");
  com();
  writeSource("           call MPI_BCAST(ibuf,datasets,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)");
  com();
  com();
  writeSource("           if(myrank .NE. 0) then");
  writeSource("              bdsetPtr\%solveNo  = solveNo");
  writeSource("              bdsetPtr\%condNo   = condNo");
  writeSource("              bdsetPtr\%condType = 1          ! dcond = 1 , ncond = 2");
  writeSource("              bdsetPtr\%nofsets  = datasets");
  writeSource("              bdsetPtr\%datlist  =>ibuf");
  writeSource("           end if");
  com();
  writeSource("        end do  ! do j=1,dconds");
  com();
  writeSource("     end if  ! if(dconds > 0)");
  com();
  com();
  writeSource("     !------------------------");
  writeSource("     ! neumann condition");
  writeSource("     !------------------------");
  writeSource("     if(nconds > 0) then");
  com();
  writeSource("        ! dlst is type(boundaryDataSet),dimension(:),pointer");
  writeSource("        if(myrank .EQ. 0) then");
  writeSource("           nlst => solveInfoPtr\%nlst");
  writeSource("        else");
  writeSource("           allocate(nlst(nconds))");
  writeSource("           solveInfoPtr\%nlst =>nlst");
  writeSource("        end if");
  com();
  writeSource("        do j=1,nconds");
  com();
  writeSource("           bdsetPtr => nlst(j)   ! bdsetPtr");
  com();
  writeSource("           if(myrank .EQ. 0) then");
  writeSource("              condNo   =  bdsetPtr\%condNo");
  writeSource("              datasets =  bdsetPtr\%nofsets");
  writeSource("           endif");
  com();
  writeSource("           call MPI_BCAST(condNo,   1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)");
  writeSource("           call MPI_BCAST(datasets, 1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)");
  com();
  writeSource("           if(myrank .EQ. 0) then");
  writeSource("              ibuf     => bdsetPtr\%datlist   ! size is datasets");
  writeSource("           else");
  writeSource("              allocate(ibuf(datasets))       ! size is datasets");
  writeSource("           end if");
  com();
  writeSource("           call MPI_BCAST(ibuf,datasets,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)");
  com();
  com();
  writeSource("           if(myrank .NE. 0) then");
  writeSource("              bdsetPtr\%solveNo  = solveNo");
  writeSource("              bdsetPtr\%condNo   = condNo");
  writeSource("              bdsetPtr\%condType = 2          ! dcond = 1 , ncond = 2");
  writeSource("              bdsetPtr\%nofsets  = datasets");
  writeSource("              bdsetPtr\%datlist  =>ibuf");
  writeSource("           end if");
  com();
  writeSource("        end do  ! do j=1,nconds");
  com();
  writeSource("     end if  ! if(nconds > 0)");
  com();
  writeSource("  end do  ! do i=1,solves");
  com();
  writeSource("end subroutine probInfoDistribute");
  writeSource("end module mod_probInfoDistribute");
  com();
  com();
  com();

  // ORIGINAL SOURCE END-------------------

  CloseSource();

  return;
}
