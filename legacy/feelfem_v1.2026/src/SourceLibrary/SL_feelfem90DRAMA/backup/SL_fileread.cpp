/*
 *  feelfem version 1.0  Copyright(c)  NEC Corporation 1999,2000
 *                       Programmed by Hidehiro  FUJIO
 *
 *  Filename : SL_fileread.cpp
 *  Date     : 2000/11/21
 *  Modified : 2000/11/21
 *  
 *  Purpose  : fileread.f90 routine
 *  
 */
#include "SL_feelfem90DRAMA.hpp"

void SL_feelfem90DRAMA::SL_fileread(int makeFlag)
{
  char *sourceName;
  
  sourceName = GetSourceName("fileread");
  OpenSource(sourceName);
  StoreSource(sourceName,makeFlag);

  writeSource("module fileread");
  com();
  writeSource("integer,parameter,private   :: ioin  = 10            ! Read open unit number");
  com();
  com();
  com();
  writeSource("contains");
  com();
  writeSource("subroutine ctrlinp(meshDat, solveLst,ierror)");
  writeSource("use femDataType");
  writeSource("use numeric");
  writeSource("implicit none");
  com();
  writeSource("type(meshInformation)        :: meshDat");
  writeSource("type(solveList)              :: solveLst");
  writeSource("integer                      :: ierror");
  com();
  com();
  writeSource("!-------------------------------------------");
  writeSource("! Auto variables");
  writeSource("!-------------------------------------------");
  writeSource("integer                      :: i");
  com();
  writeSource("character(len = 4)           :: word");
  com();
  writeSource("! Input buffer pointer");
  com();
  writeSource("integer,dimension(:),pointer :: inpbuf");
  com();
  writeSource("! for Mesh information");
  writeSource("integer                      :: nredat,nbedat");
  com();
  writeSource("! for Solve information");
  writeSource("integer                        :: solves");
  writeSource("type(solveInformation),pointer :: solveInfoPtr");
  writeSource("type(solveInformation), &");
  writeSource("    dimension(:),pointer       :: solveDataList");
  com();
  com();
  com();
  writeSource("!-------------------------------");
  writeSource("ierror = Non");
  com();
  writeSource("open(ioin,file='solv_dat',status='old',action='read')");
  com();
  writeSource("!----------------");
  writeSource("! PROB Keyword ");
  writeSource("!----------------");
  writeSource("read(ioin,'(a4)') word");
  writeSource("if(word .ne. 'PROB') then");
  writeSource("  ierror = Oui");
  writeSource("  close(ioin)");
  writeSource("  write(*,*) 'solve_dat DATA ERR(KEYWORD PROB NOT FOUND)'");
  writeSource("  return");
  writeSource("endif");
  com();
  writeSource("!----------------");
  writeSource("! MEDT  Main edat");
  writeSource("!----------------");
  writeSource("read(ioin,'(a4)') word");
  writeSource("if(word .ne. 'MEDT') then");
  writeSource("  ierror = Oui");
  writeSource("  close(ioin)");
  writeSource("  write(*,*) 'solve_dat DATA ERR(KEYWORD MEDT NOT FOUND)'");
  writeSource("  return");
  writeSource("endif");
  com();
  com();
  writeSource("read(ioin,'(i8)') meshDat%medtNo");
  com();
  writeSource("!-----------------");
  writeSource("! REDT Region edat");
  writeSource("!-----------------");
  writeSource("read(ioin,'(a4)') word");
  writeSource("if(word .ne. 'REDT') then");
  writeSource("  ierror = Oui");
  writeSource("  close(ioin)");
  writeSource("  write(*,*) 'solve_dat DATA ERR(KEYWORD REDT NOT FOUND)'");
  writeSource("  return");
  writeSource("endif");
  com();
  writeSource("read(ioin,'(i8)') nredat");
  writeSource("allocate(inpbuf(nredat))");
  writeSource("meshDat%regionEdats =  nredat");
  writeSource("meshDat%redatlist   => inpbuf");
  com();
  writeSource("read(ioin,'((8i8))') (inpbuf(i),i=1,nredat)");
  com();
  writeSource("!-------------------");
  writeSource("! BEDT Boundary edat");
  writeSource("!-------------------");
  writeSource("read(ioin,'(a4)') word");
  writeSource("if(word .ne. 'BEDT') then");
  writeSource("  ierror = Oui");
  writeSource("  close(ioin)");
  writeSource("  write(*,*) 'solve_dat DATA ERR(KEYWORD BEDT NOT FOUND)'");
  writeSource("  return");
  writeSource("endif");
  com();
  writeSource("read(ioin,'(i8)') nbedat");
  writeSource("meshDat%boundaryEdats =  nbedat");
  com();
  writeSource("if(nbedat .ne. 0) then");
  writeSource("  allocate(inpbuf(nbedat))");
  writeSource("  meshDat%bedatlist     => inpbuf");
  writeSource("  read(ioin,'((8i8))') (inpbuf(i),i=1,nbedat)");
  writeSource("else");
  writeSource("  nullify(meshDat%bedatlist)");
  writeSource("endif");
  com();
  writeSource("!-------------------------");
  writeSource("! Solve information");
  writeSource("!-------------------------");
  writeSource("read(ioin,'(a4)') word");
  writeSource("if(word .ne. 'SLVS') then");
  writeSource("  ierror = Oui");
  writeSource("  close(ioin)");
  writeSource("  write(*,*) 'solve_dat DATA ERR(KEYWORD SLVS NOT FOUND)'");
  writeSource("  return");
  writeSource("endif");
  com();
  writeSource("read(ioin,'(i8)') solves");
  writeSource("solveLst%solves = solves");
  com();
  writeSource("!----------------------");
  writeSource("! Solve DATA repetition");
  writeSource("!----------------------");
  writeSource("!do i=1,solves");
  writeSource("!");
  writeSource("!read(ioin,'(a4)') word");
  writeSource("!if(word .ne. 'SLVS') then");
  writeSource("!  ierror = Oui");
  writeSource("!  close(ioin)");
  writeSource("!  write(*,*) 'solve_dat DATA ERR(KEYWORD SLVS NOT FOUND)'");
  writeSource("!  return");
  writeSource("!endif");
  writeSource("!");
  writeSource("!");
  writeSource("! Now not used");
  writeSource("!");
  writeSource("!-----------------------");
  com();
  com();
  com();
  com();
  com();
  writeSource("close(ioin) ");
  com();
  writeSource("end subroutine ctrlinp");
  com();
  com();
  com();
  writeSource("subroutine datinp(ndim,npmax,nelem_g,nedat,nnset,nnum,nip,         &");
  writeSource("                  mode_ex,mode_output,nvars_fem,nvars_ewise,       &");
  writeSource("                  x,y,z,                                           &");
  writeSource("                  firstEdatPtr,firstNsetPtr,ipData ,ierror         )");
  com();
  writeSource("use numeric");
  writeSource("use femDataType");
  writeSource("implicit none");
  com();
  com();
  writeSource("! feel_dat fundamental parameters");
  com();
  writeSource("integer(kind=INT4 )            :: ndim             ! space dimension ");
  writeSource("integer(kind=INT4 )            :: npmax            ! nodes(global/local)");
  writeSource("integer(kind=INT4 )            :: nelem_g          ! number of region element");
  writeSource("integer(kind=INT4 )            :: nedat");
  writeSource("integer(kind=INT4 )            :: nnset");
  writeSource("integer(kind=INT4 )            :: nnum");
  writeSource("integer(kind=INT4 )            :: nip");
  writeSource("!");
  writeSource("integer(kind=INT4 )            :: mode_ex");
  writeSource("integer(kind=INT4 )            :: mode_output");
  writeSource("integer(kind=INT4 )            :: nvars_fem,nvars_ewise");
  com();
  writeSource("real   (kind=REAL8),dimension(:),pointer :: x,y,z");
  com();
  writeSource("type(edatList),pointer         :: firstEdatPtr");
  writeSource("type(nsetList),pointer         :: firstNsetPtr");
  writeSource("type(ipdat)   ,pointer         :: ipData");
  com();
  writeSource("integer(kind=INT4 )            :: ierror");
  com();
  writeSource("!---------------------------------------------------------------");
  writeSource("! Auto variable");
  writeSource("!---------------------------------------------------------------");
  com();
  writeSource("integer                        :: i,j");
  com();
  writeSource("! --------");
  writeSource("! feel_dat");
  writeSource("! --------");
  writeSource("character(len = 4 )            :: word                       ! feel_dat keyword");
  writeSource("integer                        :: nodeFlag,edatFlag,nsetFlag");
  com();
  writeSource("! ------------");
  writeSource("! EDAT/NSET/IP");
  writeSource("! ------------");
  writeSource("integer                        :: no");
  writeSource("integer                        :: np");
  com();
  writeSource("! ----");
  writeSource("! EDAT");
  writeSource("! ----");
  writeSource("type(edat), pointer            :: edatData");
  writeSource("type(edatList),pointer         :: currentEdatPtr,edatPtr");
  com();
  writeSource("integer(kind=INT4 )            :: netype");
  writeSource("integer,dimension(:,:),pointer :: ielem             ! for reading");
  writeSource("integer,dimension(:)  ,pointer :: matno             ! for reading");
  com();
  writeSource("integer                        :: nelem");
  com();
  writeSource("! ----");
  writeSource("! NSET");
  writeSource("! ----");
  writeSource("type(nset), pointer            :: nsetData");
  writeSource("type(nsetList),pointer         :: currentNsetPtr,nsetPtr");
  com();
  writeSource("integer,dimension(:,:),pointer :: inset ");
  writeSource("integer                        :: nodes");
  com();
  writeSource("! ----");
  writeSource("! NODE");
  writeSource("! ----");
  writeSource("integer                        :: inp");
  writeSource("real   (kind=REAL8)            :: xx,yy,zz          ! for reading");
  com();
  com();
  writeSource("! ----");
  writeSource("! IP");
  writeSource("! ----");
  writeSource("integer,dimension(:),pointer   :: ipno");
  com();
  com();
  com();
  writeSource("!-----------------------");
  writeSource("! Read feel_dat datafile");
  writeSource("!-----------------------");
  writeSource("  ierror = Non");
  com();
  writeSource("  open(ioin,file='feel_dat',status ='old',action='read')");
  com();
  writeSource("  read(ioin,'(a4)') word");
  writeSource("  if(word .ne. 'FEEL') then");
  writeSource("    write(*,*) 'First keyword is not FEEL'");
  writeSource("    ierror = Oui");
  writeSource("    close(ioin)");
  writeSource("    return");
  writeSource("  endif");
  writeSource("!");
  writeSource("  read(ioin,'(6i8)') ndim,npmax,nedat,nnset,nnum,nip");
  writeSource("  read(ioin,'(2i8)') mode_ex,mode_output");
  writeSource("  read(ioin,'(2i8)') nvars_fem,nvars_ewise");
  com();
  writeSource("  nodeFlag = notYet");
  writeSource("  edatFlag = notYet");
  writeSource("  nsetFlag = notYet");
  writeSource("!");
  writeSource("  nullify(firstNsetPtr,firstEdatPtr,ipData)");
  com();
  writeSource("!");
  com();
  writeSource("1000 read(ioin,'(a4)') word");
  com();
  writeSource("  select case(word)");
  writeSource("   case('END ') ");
  writeSource("     goto 1999");
  com();
  writeSource("   case('NODE') ");
  writeSource("     if(nodeFlag == already) then");
  writeSource("       write(*,*)'NODE section duplicate'");
  writeSource("       ierror = Oui");
  writeSource("       close(ioin)");
  writeSource("       return");
  writeSource("     endif");
  writeSource("     nodeFlag = already");
  com();
  writeSource("     allocate(x(npmax),y(npmax))");
  writeSource("1001 read(ioin,'(i8,E12.5,E12.5)') inp,xx,yy");
  writeSource("     if(inp .ne. 0) then");
  writeSource("       x(inp)=xx; y(inp)=yy; goto 1001");
  writeSource("     endif");
  com();
  writeSource("   case('EDAT') ");
  writeSource("     read(ioin,'(4i8)') no,nelem,np,netype");
  com();
  writeSource("     if(no .eq. 1) then");
  writeSource("       nelem_g = nelem         ! feel_dat limitation");
  writeSource("     endif");
  com();
  writeSource("     allocate(edatData,edatPtr,ielem(np,nelem),matno(nelem))");
  writeSource("     edatData%ielem => ielem");
  writeSource("     edatData%matno => matno");
  writeSource("     edatData%no    =  no");
  writeSource("     edatData%nelem =  nelem");
  writeSource("     edatData%np    =  np");
  writeSource("     edatData%netype=  netype");
  com();
  writeSource("     edatPtr%no       =  no             ! List pointer has also no. data");
  writeSource("     edatPtr%edatData => edatData");
  writeSource("     nullify(edatPtr%next)");
  writeSource("     ");
  writeSource("   ");
  writeSource("     if(edatFlag == notYet) then");
  writeSource("       firstEdatPtr=>edatPtr");
  writeSource("       currentEdatPtr=>edatPtr");
  writeSource("       edatFlag  = already ");
  writeSource("     else");
  writeSource("       currentEdatPtr%next =>edatPtr");
  writeSource("       currentEdatPtr=>edatPtr");
  writeSource("     endif");
  writeSource("    ");
  com();
  writeSource("     do i=1,nelem");
  writeSource("      read(ioin,*) (ielem(j,i),j=1,np),matno(i)");
  writeSource("     end do");
  com();
  com();
  com();
  writeSource("   case('NSET') ");
  writeSource("     read(ioin,'(3i8)') no,nodes,np");
  com();
  writeSource("     allocate(nsetData,nsetPtr,inset(np,nodes))");
  writeSource("     nsetData%inset   =>inset");
  writeSource("     nsetData%no      = no");
  writeSource("     nsetData%np      = np");
  writeSource("     nsetData%nodes   = nodes");
  com();
  writeSource("     nsetPtr%no       = no");
  writeSource("     nsetPtr%nsetData => nsetData");
  writeSource("     nullify(nsetPtr%next)");
  com();
  writeSource("     if(nsetFlag == notYet) then");
  writeSource("       firstNsetPtr   => nsetPtr");
  writeSource("       currentNsetPtr => nsetPtr");
  writeSource("       nsetFlag       =  already");
  writeSource("     else");
  writeSource("       currentNsetPtr%next => nsetPtr");
  writeSource("       currentNsetPtr      => nsetPtr");
  writeSource("     endif");
  com();
  writeSource("     do i=1,nodes");
  writeSource("       read(ioin,*) (inset(j,i),j=1,np)");
  writeSource("     end do");
  com();
  com();
  com();
  writeSource("   case('NUM ') ");
  writeSource("     write(*,*) 'Keyword NUM '");
  com();
  writeSource("   case('IP  ') ");
  writeSource("     allocate(ipData,ipno(nip))");
  com();
  writeSource("     ipData%ipno     => ipno");
  writeSource("     ipData%nodes    =  nip");
  com();
  writeSource("     read(ioin,'((8i8))') (ipno(i),i=1,nip)");
  com();
  com();
  writeSource("  end select");
  com();
  writeSource("  goto 1000 ");
  writeSource("   ");
  com();
  writeSource("1999 close(ioin)");
  com();
  writeSource("end subroutine datinp");
  com();
  writeSource("subroutine read_metis(nprocs,nelem_g,metis,ierror)");
  writeSource("!---");
  writeSource("use numeric");
  writeSource("implicit none");
  com();
  writeSource("integer                    :: nprocs");
  writeSource("integer                    :: nelem_g");
  writeSource("integer,dimension(nelem_g) :: metis");
  writeSource("integer                    :: ierror");
  com();
  writeSource("!auto variable");
  writeSource("integer                    :: i");
  writeSource("integer                    :: inp");
  writeSource("integer                    :: nprocs_check");
  writeSource("integer                    :: metis2feel(nelem_g)");
  writeSource("!---");
  com();
  writeSource("  ierror = Non");
  com();
  writeSource("  open(ioin,file='metis.bamg',status='old',action='read')");
  writeSource("  do i=1,nelem_g");
  writeSource("    read(ioin,*) metis2feel(i)");
  writeSource("  end do");
  writeSource("  close(ioin)");
  com();
  writeSource("  open(ioin,file='metis.feel',status='old',action='read')");
  writeSource("  do i=1,nelem_g");
  writeSource("    read(ioin,*) inp");
  writeSource("    metis(inp) = metis2feel(i)");
  writeSource("  end do");
  writeSource("  close(ioin)");
  com();
  writeSource("  nprocs_check = -1");
  writeSource("  do i=1,nelem_g");
  writeSource("    if(nprocs_check < metis(i)) then");
  writeSource("      nprocs_check = metis(i)");
  writeSource("    end if");
  writeSource("  end do");
  writeSource("  nprocs_check = nprocs_check + 1");
  com();
  writeSource("  if(nprocs .ne. nprocs_check) then");
  writeSource("    write(*,*) 'Number of processor is mismatch'");
  writeSource("    ierror = Oui");
  writeSource("    return");
  writeSource("  endif");
  com();
  writeSource("end subroutine read_metis");
  com();
  writeSource("end module fileread");

  CloseSource();

  return;
}
