module mod_solve1
contains

subroutine solve1(npmax,x,y,z,                    &
   firstEdatPtr,firstNsetPtr, solveLst &
,fem_u,fem_v,sc_d,sc_s)
!--------------------------------------------------------
! Generated by feelfem
!--------------------------------------------------------
! feelfem90 Program Model
! 2025/12/23 06:08
!----------------------------------------------------
! skyline solver related modules
use mod_skyline_solver

! Matrix data structure related modules
use mod_mat_skyline

! modules for solve
use femDataType
use feelP2data
use subsolveff90p2

! general modules
use report90
use numeric
use abortmodule


! solve family
use mod_elem1
use mod_dcond1_1
use mod_ncond1_1
use mod_ipdinfo1_1
use mod_edev1_1

implicit none


integer(kind=INT4 )                  :: npmax
real(kind=REAL8),dimension(:)  ,pointer :: x,y,z
type (edatList),pointer         :: firstEdatPtr
type (nsetList),pointer         :: firstNsetPtr
type (SolveList)                :: solveLst

real(kind=REAL8),dimension(:)  ,pointer :: fem_u
real(kind=REAL8),dimension(:)  ,pointer :: fem_v
real(kind=REAL8)                        :: sc_d
real(kind=REAL8)                        :: sc_s


!------------------------------------------------------
! Problem dependent variables
!------------------------------------------------------
integer,parameter         :: neg = 1
integer,parameter         :: maxElementNodes = 10
integer,parameter         :: dirichletSets =1
integer,parameter         :: neumannSets =1
!------------------------------------------------------

!------------------------------------------------------
! auto variables
!------------------------------------------------------
integer                                 :: i,j,no
integer                                 :: nelem,np,netype
integer,dimension(:,:),pointer          :: ielem
integer,dimension(:)  ,pointer          :: matno

integer,dimension(:)  ,pointer          :: ipd,ipf
integer                                 :: neq

integer,dimension(:)  ,pointer          :: ipd_u
integer,dimension(:)  ,pointer          :: ipd_v

!------------------------------------------------------
! Problem dependent parameters
!------------------------------------------------------
integer                                 :: solveNo
integer                                 :: edatno
integer                                 :: nenfre(maxElementNodes,neg)
type(solveInformation),pointer          :: solveInfoPtr
type(boundaryDataSet) ,pointer          :: bDatSetPtr
!------------------------------------------------
!  Element equation topology variable
!------------------------------------------------
integer                        :: ncmax         ! maximum number of elements
                                                ! connecting one node

integer                        :: ndfmax        ! maximum freedom for
                                                ! one element

integer                        :: nenfremax     ! maximum freedom per one node
                                                ! for each element

integer                        :: ncon          ! maximum freedom per one node
                                                ! including connecting elements

!------------------------------------------------------
! Matrix related variables
!------------------------------------------------------
real(kind=REAL8),dimension(:)  ,pointer :: vkgs,vkgd,vkgi,vfg
integer,dimension(:)  ,pointer          :: kld,kh
integer                                 :: ncof
integer,dimension(:)  ,pointer          :: kha


!------------------------------------------------------
! Solver Library dependent variables(Skyline)
!------------------------------------------------------
integer                                 :: IFAC,ISOL,NSYM
real(kind=REAL8)                        :: ENERG        ! not used


!------------------------------------------------------
! Problem parameters
!------------------------------------------------------
data nenfre/2,2,2,2,0,0,0,0,0,0/

call report('SOLVE 1 START')

solveNo      =  1
solveInfoPtr => solveLst%solveDataList(solveNo)
edatno       = solveInfoPtr%edatno


!------------------------------------------------------
!  allocate enptr,con,matno in the next subroutine
!------------------------------------------------------
call setP2edat(edatno,firstEdatPtr,nelem,np,netype,ielem,matno)

if(np .NE. maxElementNodes) then
  write(*,*) '**************************************'
  write(*,*) '*           MESH ERROR               *'
  write(*,*) '*                                    *'
  write(*,*) '*  Number of nodes in one element is *'
  write(*,*) '*  not what is expected.  Maybe mesh *'
  write(*,*) '*  data mismatch.                    *'
  write(*,*) '*                                    *'
  write(*,*) '**************************************'
  write(*,*)
  stop '(Element type mismatches linear / quadratic, etc.)'
endif

if(dirichletSets .NE. solveInfoPtr%dconds) then
  write(*,*) '**************************************'
  write(*,*) '*           MESH ERROR               *'
  write(*,*) '*                                    *'
  write(*,*) '*  Number of dirichlet conditions is *'
  write(*,*) '*  not what is expect. Maybe mesh    *'
  write(*,*) '*  data mismatch.                    *'
  write(*,*) '*                                    *'
  write(*,*) '**************************************'
  write(*,*)
  stop '(Number of Dirichlet condition mismatches.)'
endif

if(neumannSets .NE. solveInfoPtr%nconds) then
  write(*,*) '**************************************'
  write(*,*) '*           MESH ERROR               *'
  write(*,*) '*                                    *'
  write(*,*) '*  Number of Neumann conditions is   *'
  write(*,*) '*  not what is expect. Maybe mesh    *'
  write(*,*) '*  data mismatch.                    *'
  write(*,*) '*                                    *'
  write(*,*) '**************************************'
  write(*,*)
  stop '(Number of Neumann condition mismatches.)'
endif


!------------------------------------------------------
!  Construct ipf,ipd
!------------------------------------------------------
allocate(ipf(npmax))
allocate(ipd(npmax))
allocate(ipd_u(npmax))
allocate(ipd_v(npmax))

call makeipfp2(nenfre,maxElementNodes,neg, &
               ielem,nelem,np,npmax,ipf    )

call makeipdp2(ipf,ipd,npmax,neq)

call reportmodule('makeipf,makeipd')

call ipdinfo1_1(npmax,ielem,nelem,np,ipd_u,ipd_v)
!------------------------------------------------------
! Boundary Data is prepared before solve 1
! in DRAMA MPI parallel version.
!------------------------------------------------------

!------------------------------------------------------
! Matrix array allocation  (Skyline:Program Model feelfem90)
!------------------------------------------------------
allocate(kld(neq+1))
allocate(kh(neq))
allocate(kha(npmax))

call zeroi(kha,npmax)

call cal_ht_a(ielem,nelem,np,kha,npmax)

! make KH array
call cal_ht(kha,kh,ipf,ipd,npmax,neq)

! make kld
call make_kld(kh,kld,neq,ncof)

deallocate(kha)

! vkgs(upper) vkgi(lower) vkgd(diagonal)
allocate(vkgs(ncof))
allocate(vkgi(ncof))
allocate(vkgd(neq))
allocate(vfg(neq))

call zerod(vkgs,ncof)
call zerod(vkgi,ncof)
call zerod(vkgd,neq)
call zerod(vfg,neq)


!------------------------------------------------------
!  Assemble routine call
!------------------------------------------------------
call elem1(ielem,matno,nelem,np,              &
      x,y,z,ipf,ipd,npmax                       &
     ,vkgs,vkgd,vkgi,ncof,vfg,kld,kh,neq)

 call report('solve1 : Assemble routine')

!------------------------------------------------------
! Neumann Conditions
!------------------------------------------------------
!------------------------------------------------------
! No.1

bdatSetPtr => solveInfoPtr%nlst(1)

do i=1,bdatSetPtr%nofsets

  no = bDatSetPtr%datlist(i)
  call ncond1_1(no,firstEdatPtr,          &
     npmax,x,y,z,ipf,ipd                             &
    ,fem_u,fem_v,sc_d,sc_s,vkgs,vkgd,vkgi,ncof,vfg,kld,kh,neq)
end do


 call report('solve1 : Neumann routine')

!------------------------------------------------------
! Dirichlet Conditions
!------------------------------------------------------
!------------------------------------------------------
! No.1

bdatSetPtr => solveInfoPtr%dlst(1)

do i=1,bdatSetPtr%nofsets

  no = bDatSetPtr%datlist(i)
  call dcond1_1(no,firstNsetPtr,          &
       x,y,z,ipf,ipd,ipd_u,npmax                     &
       ,vkgs,vkgd,vkgi,ncof,vfg,kld,kh,neq)
end do


 call report('solve1 : Dirichlet routine')

!------------------------------------------------------
! Matrix dependent initialization
!------------------------------------------------------
! none required for AMGCRS


!------------------------------------------------------
! Solver parameters
!------------------------------------------------------
  IFAC = 1
  ISOL = 1
  NSYM = 1


!------------------------------------------------------
!  Call Skyline solver
!------------------------------------------------------
  call skyline_sol(vkgs,vkgd,vkgi,vfg,kld,neq,5,IFAC,ISOL,NSYM,ENERG)

 call report('solve1 : Solver routine')

!------------------------------------------------------
! Call Edev Routine
!------------------------------------------------------
call edev1_1(vfg,ipd, &
  ielem,nelem,np,fem_u,fem_v)
!------------------------------------------------------

!------------------------------------------------------
! deallocate matrix related arrays
!------------------------------------------------------
if(associated(kld)) then
 deallocate(kld)
end if

if(associated(kh)) then
 deallocate(kh)
end if

if(associated(vkgi)) then
 deallocate(vkgi)
end if

if(associated(vkgs)) then
 deallocate(vkgs)
end if

if(associated(vkgd)) then
 deallocate(vkgd)
end if

deallocate(vfg)


!------------------------------------------------------
! ProgramModel dependent memory deallocation
!------------------------------------------------------
deallocate(ipd,ipf)
deallocate(ipd_u)
deallocate(ipd_v)
end subroutine solve1
end module mod_solve1
