/*
 *  feelfem v1.0 NEC Corporation (C) 1999,2000,2001
 *                   Programmed  by  Hidehiro FUJIO
 *
 *  Filename : SL_feelfem90mp.cpp
 *  Date     : 2003/03/02 20:50
 *  Purpose  : Library module generator
 *
 */
#include "SL_feelfem90DRAMA.hpp"

static int come_yet_feelfem90mp = 0;


void SL_feelfem90DRAMA::SL_feelfem90mp(int makeFlag)
{
  char *sourceName;

  if(come_yet_feelfem90mp == 1)  return;
  else                  come_yet_feelfem90mp = 1;

  sourceName = GetSourceName("feelfem90mp");
  OpenSource(sourceName,makeFlag);

  // ORIGINAL SOURCE STARTS-----------------


  writeSource("module feelfem90mp");
  writeSource("!--------------------------------------------------------");
  writeSource("! Message passing sub module for feelfem90");
  com();
  writeSource("! subroutine ff90gathervbcast    ! for 1-dimensional array");
  writeSource("! subroutine ff90gathervbcast2   ! for 2-dimensional array");
  writeSource("!                                ! counts,displs are divided by np");
  com();
  com();
  writeSource("!--------------------------------------------------------");
  com();
  writeSource("contains");
  writeSource("subroutine ff90allgather(myrank,nprocs,count,mybuf,buf   )");
  com();
  writeSource("! allocate receive buffer and calls mpi_allgather");
  com();
  writeSource("use abortmodule");
  writeSource("implicit none");
  com();
  writeSource("include 'mpif.h'");
  com();
  writeSource("integer,intent(in)           :: myrank,nprocs");
  writeSource("integer,intent(in)           :: count");
  writeSource("integer,dimension(:)         :: mybuf");
  writeSource("integer,dimension(:),pointer :: buf              ! allocate here");
  com();
  writeSource("!auto variable");
  writeSource("integer                      :: ierror");
  com();
  com();
  com();
  writeSource("if(count .le. 0) then");
  writeSource("  write(*,*) '[ff90allgather] count =',count");
  writeSource("  call abortexit(myrank)");
  writeSource("endif");
  com();
  writeSource("allocate(buf(nprocs*count))");
  writeSource("call MPI_ALLGATHER(mybuf,count,MPI_INTEGER,               &");
  writeSource("                   buf  ,count,MPI_INTEGER,MPI_COMM_WORLD,ierror)");
  com();
  com();
  writeSource("end subroutine ff90allgather");
  com();
  writeSource("subroutine ff90gathervbcast(myrank,nprocs,mycount,mybuf, &");
  writeSource("                            buf,counts,displs            )");
  writeSource("use abortmodule");
  writeSource("implicit none");
  com();
  writeSource("include 'mpif.h'");
  com();
  writeSource("integer,intent(in)           :: myrank,nprocs");
  writeSource("integer,intent(in)           :: mycount");
  writeSource("integer,dimension(:),pointer :: mybuf");
  writeSource("integer,dimension(:),pointer :: buf              ! allocate here");
  writeSource("integer,dimension(:),pointer :: counts           ! allocate here");
  writeSource("integer,dimension(:),pointer :: displs           ! allocate here");
  com();
  writeSource("! auto variables");
  com();
  writeSource("integer                      :: i                ! for loop counter");
  writeSource("integer                      :: idisp,nwords     ! for counting");
  writeSource("integer                      :: ierror");
  com();
  com();
  writeSource("!------");
  com();
  com();
  writeSource("if(mycount < 0) then");
  writeSource("  write(*,*) '[ff90gathervbcast] myrank=',myrank,' mycount=',mycount");
  writeSource("  call abortexit(myrank)");
  writeSource("endif");
  com();
  writeSource("!if(mycount == 0) then");
  writeSource("!  allocate(sendbuffer(2))");
  writeSource("!else");
  writeSource("!  sendbuffer = mybuf");
  writeSource("!endif");
  com();
  com();
  writeSource("allocate(counts(nprocs),displs(nprocs))");
  com();
  writeSource("call MPI_GATHER(mycount,   1, MPI_INTEGER,         &");
  writeSource("                counts ,   1, MPI_INTEGER, 0,      &");
  writeSource("                              MPI_COMM_WORLD,ierror)");
  writeSource("!----");
  writeSource("! now only PE0 has counts(*) array");
  writeSource("!----");
  com();
  writeSource("if(myrank .eq. 0) then");
  writeSource("  idisp = 0");
  writeSource("  do i=1,nprocs");
  writeSource("    displs(i) = idisp");
  writeSource("    idisp = idisp + counts(i)");
  writeSource("  end do");
  writeSource("  nwords = idisp");
  writeSource("endif");
  com();
  writeSource("!---");
  writeSource("! now only PE0 has displs(*) array");
  writeSource("!---");
  com();
  writeSource("! scatter buffer size nwords");
  writeSource("call MPI_BCAST(nwords,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  com();
  writeSource("!allocate recieve buffer in each processor");
  writeSource("allocate(buf(nwords))");
  com();
  writeSource("! scatter counts/displs array");
  writeSource("call MPI_BCAST(counts,nprocs,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  writeSource("call MPI_BCAST(displs,nprocs,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  com();
  writeSource("! gather and scatter data");
  com();
  writeSource("call MPI_GATHERV(mybuf,mycount,MPI_INTEGER,buf,counts,displs, &");
  writeSource("                               MPI_INTEGER,  0,MPI_COMM_WORLD,ierror)");
  writeSource("call MPI_BCAST(buf,nwords,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  com();
  com();
  writeSource("!if(mycount == 0) then");
  writeSource("! deallocate(sendbuffer)");
  writeSource("!endif");
  com();
  writeSource("end subroutine ff90gathervbcast");
  com();
  com();
  writeSource("subroutine ff90gathervbcast2(myrank,nprocs,np,n,mybuf, &");
  writeSource("                             buf,counts,displs            )");
  com();
  writeSource("!  counts,displs are divided by np for 2-dimensional array");
  com();
  com();
  com();
  writeSource("use abortmodule");
  writeSource("implicit none");
  com();
  writeSource("include 'mpif.h'");
  com();
  writeSource("integer,intent(in)              :: myrank,nprocs");
  writeSource("integer,intent(in)              :: np,n");
  writeSource("integer,dimension(:,:) ,pointer :: mybuf");
  writeSource("integer,dimension(:,:) ,pointer :: buf              ! allocate here");
  com();
  writeSource("integer,dimension(:)   ,pointer :: counts           ! allocate here");
  writeSource("integer,dimension(:)   ,pointer :: displs           ! allocate here");
  com();
  writeSource("! auto variables");
  com();
  writeSource("integer                      :: i                ! for loop counter");
  writeSource("integer                      :: idisp,nwords     ! for counting");
  writeSource("integer                      :: ntimes");
  writeSource("integer                      :: mycount");
  writeSource("integer                      :: ierror");
  com();
  writeSource("!integer,dimension(:,:) ,pointer :: sendbuffer       ! for PGI");
  writeSource("!integer,dimension(2,1)          :: tempbuffer");
  com();
  writeSource("!------");
  com();
  writeSource("mycount = np * n");
  com();
  writeSource("if(mycount < 0) then");
  writeSource("  write(*,*) '[ff90gathervbcast2] myrank=',myrank,' np=',np,' n=',n");
  writeSource("  call abortexit(myrank)");
  writeSource("endif");
  com();
  writeSource("!if(mycount == 0) then");
  writeSource("!  sendbuffer = mybuf");
  writeSource("!else");
  writeSource("!  allocate(sendbuffer(2,1))");
  writeSource("!endif");
  com();
  com();
  writeSource("allocate(counts(nprocs),displs(nprocs))");
  com();
  writeSource("call MPI_GATHER(mycount,   1, MPI_INTEGER,         &");
  writeSource("                counts ,   1, MPI_INTEGER, 0,      &");
  writeSource("                              MPI_COMM_WORLD,ierror)");
  writeSource("!----");
  writeSource("! now only PE0 has counts(*) array");
  writeSource("!----");
  com();
  writeSource("if(myrank .eq. 0) then");
  writeSource("  idisp = 0");
  writeSource("  do i=1,nprocs");
  writeSource("    displs(i) = idisp");
  writeSource("    idisp = idisp + counts(i)");
  writeSource("  end do");
  writeSource("  nwords = idisp");
  writeSource("endif");
  com();
  writeSource("!---");
  writeSource("! now only PE0 has displs(*) array");
  writeSource("!---");
  com();
  writeSource("! scatter buffer size nwords");
  writeSource("call MPI_BCAST(nwords,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  com();
  writeSource("!allocate recieve buffer in each processor");
  writeSource("ntimes = nwords / np");
  com();
  writeSource("if(ntimes * np  .ne. nwords) then");
  writeSource(" write(*,*) 'calculation of ntimes illegal'");
  writeSource(" call abortexit(myrank)");
  writeSource("endif");
  com();
  writeSource("allocate(buf(np,ntimes))");
  com();
  com();
  writeSource("! scatter counts/displs array");
  writeSource("call MPI_BCAST(counts,nprocs,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  writeSource("call MPI_BCAST(displs,nprocs,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  com();
  writeSource("! gather and scatter data");
  writeSource("call MPI_GATHERV(mybuf,mycount,MPI_INTEGER,buf,counts,displs, &");
  writeSource("                               MPI_INTEGER,  0,MPI_COMM_WORLD,ierror)");
  writeSource("call MPI_BCAST(buf,nwords,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  com();
  writeSource("! Adjust for counts/displs for 2-dimensional array");
  writeSource("do i=1,nprocs");
  writeSource(" counts(i)=counts(i)/np");
  writeSource(" displs(i)=displs(i)/np");
  writeSource("end do");
  com();
  com();
  writeSource("end subroutine ff90gathervbcast2");
  com();
  com();
  writeSource("subroutine ff90gathervdbl(myrank,nprocs,npmax,ddat,dgatherbuf,npmax_g)");
  writeSource("!--------------------------------------------------------------");
  writeSource("! gatherv for double precision version");
  com();
  writeSource("! dgatherbuf is allocated here, and must be free after use");
  writeSource("!--------------------------------------------------------------");
  writeSource("  use numeric");
  com();
  writeSource("  implicit none");
  com();
  writeSource("  include 'mpif.h'");
  com();
  writeSource("  integer                               :: myrank,nprocs");
  writeSource("  integer                               :: npmax");
  writeSource("  real(kind=REAL8),dimension(:),pointer :: ddat");
  com();
  writeSource("  real(kind=REAL8),dimension(:),pointer :: dgatherbuf  !allocate here");
  com();
  writeSource("  integer                               :: npmax_g     ! all nodes");
  com();
  writeSource("! auto variables");
  writeSource("  integer                               :: i");
  writeSource("  integer,dimension(:),pointer          :: counts,displs  ! allocate&deallocate");
  writeSource("  integer                               :: ierr");
  com();
  writeSource("!--------------------------------------");
  writeSource("  npmax_g = 0");
  com();
  writeSource("  if(myrank .eq. 0) then");
  writeSource("     allocate(counts(nprocs))");
  writeSource("     allocate(displs(nprocs))");
  writeSource("  end if");
  com();
  writeSource("  call MPI_GATHER(npmax , 1,MPI_INTEGER,                       &");
  writeSource("                  counts, 1,MPI_INTEGER, 0, MPI_COMM_WORLD,ierr )");
  com();
  writeSource("  if(myrank .eq. 0) then");
  com();
  writeSource("     ! calculate npmax_g");
  writeSource("     do i=1,nprocs");
  writeSource("        npmax_g = npmax_g + counts(i)");
  writeSource("     end do");
  com();
  writeSource("     ! make displs array");
  writeSource("     displs(1) = 0");
  writeSource("     do i=2,nprocs");
  writeSource("        displs(i) = displs(i-1)+counts(i-1)");
  writeSource("     end do");
  com();
  writeSource("     allocate(dgatherbuf(npmax_g))");
  com();
  writeSource("  end if");
  com();
  writeSource("  call MPI_GATHERV(ddat,npmax,MPI_DOUBLE_PRECISION,                &");
  writeSource("                   dgatherbuf,counts,displs,MPI_DOUBLE_PRECISION,  &");
  writeSource("                   0,MPI_COMM_WORLD,ierr                           )");
  writeSource("  !");
  com();
  writeSource("  deallocate(counts,displs)");
  com();
  writeSource("  return");
  writeSource("end subroutine ff90gathervdbl");
  com();
  writeSource("end module feelfem90mp");

  // ORIGINAL SOURCE END-------------------

  CloseSource();

  return;
}
