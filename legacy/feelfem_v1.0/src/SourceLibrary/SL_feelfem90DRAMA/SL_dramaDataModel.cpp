/*
 *  feelfem v1.0 NEC Corporation (C) 1999,2000,2001
 *                   Programmed  by  Hidehiro FUJIO
 *
 *  Filename : SL_dramaDataModel.cpp
 *  Date     : 2003/03/02 20:50
 *  Purpose  : Library module generator
 *
 */
#include "SL_feelfem90DRAMA.hpp"

static int come_yet_dramaDataModel = 0;


void SL_feelfem90DRAMA::SL_dramaDataModel(int makeFlag)
{
  char *sourceName;

  if(come_yet_dramaDataModel == 1)  return;
  else                  come_yet_dramaDataModel = 1;

  sourceName = GetSourceName("dramaDataModel");
  OpenSource(sourceName,makeFlag);

  // ORIGINAL SOURCE STARTS-----------------


  writeSource("module dramaDataModel");
  com();
  writeSource("!-------------------------------------------------------------");
  writeSource("! subroutine lonumerate");
  writeSource("! subroutine mkloccoor");
  writeSource("! subroutine mkdramaedats");
  writeSource("! subroutine mkdramansets");
  writeSource("! subroutine setdramaedat");
  writeSource("! subroutine setdramanset");
  com();
  writeSource("! Date     2000/09/25");
  writeSource("! Modified 2000/10/11");
  writeSource("!-------------------------------------------------------------");
  com();
  writeSource("contains");
  com();
  writeSource("subroutine lonumerate(mypeid,nprocs,loc,npmax_g,metis,nelem_g, &");
  writeSource("                      firstEdatPtr,mynode,myelem               )");
  com();
  writeSource("! Purpose: Make a index list array for local enumeration");
  com();
  com();
  com();
  com();
  com();
  com();
  writeSource("use femDataType");
  writeSource("use abortmodule");
  com();
  writeSource("implicit none");
  com();
  com();
  writeSource("integer,parameter           :: notYetFlag = -1");
  writeSource("integer,parameter           :: NID_PLUS   =  1  ! mypeid and ID in array");
  com();
  com();
  writeSource("integer,intent(in)          :: mypeid,nprocs");
  writeSource("integer,intent(in)          :: npmax_g,nelem_g   ! total number of nodes,");
  writeSource("                                             ! region elements");
  writeSource("integer,dimension(2,npmax_g):: loc");
  writeSource("integer,dimension(nelem_g)  :: metis");
  writeSource("integer,intent(out)         :: mynode,myelem");
  com();
  writeSource("type(edatList),pointer      :: firstEdatPtr");
  com();
  writeSource("! auto variables");
  com();
  writeSource("type(edatList),pointer         :: edatPtr");
  writeSource("type(edat)    ,pointer         :: edatData");
  writeSource("integer,dimension(:,:),pointer :: ielem");
  writeSource("integer                        :: no,nelem,np");
  com();
  writeSource("integer                        :: netype        ! P2 limitation");
  com();
  com();
  com();
  writeSource("integer,dimension(nprocs)      :: icount        ! count nodes for each PE region");
  com();
  writeSource("integer                        :: i,j");
  writeSource("integer                        :: id,ipt");
  com();
  com();
  com();
  writeSource("!----");
  writeSource("! initialization");
  writeSource("!----");
  writeSource("myelem    = 0");
  writeSource("mynode    = 0");
  com();
  writeSource("do i=1,nprocs");
  writeSource("  icount(i) = 0");
  writeSource("end do");
  com();
  writeSource("do i=1,npmax_g");
  writeSource("  loc(1,i) = notYetFlag");
  writeSource("  loc(2,i) = 0");
  writeSource("end do");
  com();
  writeSource("edatPtr => firstEdatPtr");
  com();
  writeSource("make_loc_loop: do");
  writeSource("  edatData => edatPtr\%edatData");
  com();
  writeSource("  if(edatData\%nelem .eq. nelem_g) then  ! feel_dat data limitation");
  writeSource("    ielem => edatData\%ielem");
  writeSource("    np    =  edatData\%np");
  writeSource("    nelem =  edatData\%nelem");
  com();
  writeSource("    netype = edatData\%netype            ! P2 limitation (one element)");
  com();
  writeSource("    if(myelem .eq. 0) then");
  writeSource("      do i=1,nelem");
  writeSource("        if(metis(i) .eq. mypeid) then");
  writeSource("          myelem = myelem + 1");
  writeSource("        endif");
  writeSource("      end do");
  writeSource("    endif");
  com();
  writeSource("    do i=1,nelem");
  writeSource("      id = metis(i)");
  writeSource("      do j=1,np");
  com();
  writeSource("        ipt = ielem(j,i)");
  com();
  writeSource("        if(loc(1,ipt) .eq. notYetFlag ) then");
  writeSource("          loc(1,ipt) = id");
  writeSource("        else");
  writeSource("          if(loc(1,ipt) .GT. id ) then");
  writeSource("             loc(1,ipt) = id");
  writeSource("          endif");
  writeSource("        endif");
  writeSource("      end do");
  writeSource("    end do");
  writeSource("  end if");
  com();
  writeSource("  if( .not. associated(edatPtr\%next)) exit make_loc_loop");
  writeSource("  edatPtr => edatPtr\%next");
  com();
  writeSource("end do make_loc_loop");
  com();
  writeSource("! generate loc(2,*)");
  com();
  writeSource("  do i=1,npmax_g");
  writeSource("    id = loc(1,i)");
  writeSource("    if(id .eq. notYetFlag) then");
  writeSource("      write(*,*) 'Error in lonumerate:001'");
  writeSource("      call abortexit(mypeid)");
  writeSource("    endif");
  writeSource("    ipt = id + NID_PLUS");
  com();
  writeSource("    icount(ipt) = icount(ipt)+1");
  writeSource("    loc(2,i)    = icount(ipt)");
  writeSource("  end do");
  com();
  writeSource("  mynode = icount(mypeid + NID_PLUS)");
  com();
  com();
  writeSource("end subroutine lonumerate");
  writeSource("!----------------------------------------------------------------------");
  writeSource("! for 2 dimension");
  writeSource("!----------------------------------------------------------------------");
  writeSource("subroutine mkloccoor(mypeid,nprocs,x,y,loc,npmax_g,xloc,yloc,mynode)");
  writeSource("use numeric");
  writeSource("use abortmodule");
  writeSource("implicit none");
  com();
  writeSource("integer                             :: mypeid");
  writeSource("integer                             :: nprocs");
  writeSource("integer                             :: npmax_g");
  writeSource("integer                             :: mynode");
  writeSource("integer,dimension(2,npmax_g)        :: loc");
  writeSource("real(kind=REAL8),dimension(npmax_g) :: x,y");
  writeSource("real(kind=REAL8),dimension(mynode)  :: xloc,yloc");
  com();
  writeSource("! auto variables");
  writeSource("integer                             :: i,iptr");
  com();
  writeSource("  iptr = 0");
  writeSource("  do i=1,npmax_g");
  writeSource("    if(loc(1,i) .eq. mypeid) then");
  writeSource("      iptr       = iptr + 1");
  writeSource("      xloc(iptr) = x(i)");
  writeSource("      yloc(iptr) = y(i)");
  writeSource("    end if");
  writeSource("  end do");
  writeSource("  if(iptr .ne. mynode) then");
  writeSource("    write(*,*) 'mkloccoor error'");
  writeSource("    call abortexit(mypeid)");
  writeSource("  end if");
  com();
  writeSource("end subroutine mkloccoor");
  writeSource("!----------------------------------------------------------------------");
  writeSource("! for 3 dimension");
  writeSource("!----------------------------------------------------------------------");
  writeSource("subroutine mkloccoor3(mypeid,nprocs,x,y,Z,loc,npmax_g, &");
  writeSource("                      xloc,yloc,zloc,mynode)");
  writeSource("use numeric");
  writeSource("use abortmodule");
  writeSource("implicit none");
  com();
  writeSource("integer                             :: mypeid");
  writeSource("integer                             :: nprocs");
  writeSource("integer                             :: npmax_g");
  writeSource("integer                             :: mynode");
  writeSource("integer,dimension(2,npmax_g)        :: loc");
  writeSource("real(kind=REAL8),dimension(npmax_g) :: x,y,z");
  writeSource("real(kind=REAL8),dimension(mynode)  :: xloc,yloc,zloc");
  com();
  writeSource("! auto variables");
  writeSource("integer                             :: i,iptr");
  com();
  writeSource("  iptr = 0");
  writeSource("  do i=1,npmax_g");
  writeSource("    if(loc(1,i) .eq. mypeid) then");
  writeSource("      iptr       = iptr + 1");
  writeSource("      xloc(iptr) = x(i)");
  writeSource("      yloc(iptr) = y(i)");
  writeSource("      zloc(iptr) = z(i)");
  writeSource("    end if");
  writeSource("  end do");
  writeSource("  if(iptr .ne. mynode) then");
  writeSource("    write(*,*) 'mkloccoor error'");
  writeSource("    call abortexit(mypeid)");
  writeSource("  end if");
  com();
  writeSource("end subroutine mkloccoor3");
  com();
  writeSource("subroutine mkdramaedats(mypeid,nprocs,loc,npmax_g,metis,nelem_g, &");
  writeSource("                        mynode,myelem,firstEdatPtr,firstDramaEdatPtr)");
  writeSource("use numeric");
  writeSource("use femDataType");
  writeSource("use abortmodule");
  writeSource("implicit none");
  com();
  writeSource("integer,intent(in)            :: mypeid,nprocs");
  writeSource("integer,intent(in)            :: npmax_g");
  writeSource("integer,dimension(2,npmax_g)  :: loc");
  writeSource("integer,intent(in)            :: nelem_g");
  writeSource("integer,dimension(nelem_g)    :: metis");
  writeSource("integer,intent(in)            :: mynode,myelem");
  writeSource("type(edatList),pointer        :: firstEdatPtr");
  writeSource("type(dramaEdatList),pointer   :: firstDramaEdatPtr");
  com();
  writeSource("! auto variables");
  writeSource("integer                       :: isFirstDramaEdat   ! check the first edat");
  writeSource("integer                       :: i,j");
  writeSource("type(edatList),pointer        :: edatPtr");
  writeSource("type(edat),pointer            :: edatData");
  writeSource("type(dramaEdat),pointer       :: dramaEdatData");
  writeSource("type(dramaEdatList),pointer   :: currentDramaEdatPtr,dramaEdatPtr");
  com();
  writeSource("integer,dimension(:,:),pointer:: ielem");
  writeSource("integer,dimension(:)  ,pointer:: matno,matno_new");
  writeSource("integer,dimension(:,:),pointer:: enptr,con");
  com();
  writeSource("integer                       :: no,np,nelem");
  writeSource("integer                       :: netype              ! P2 limit");
  writeSource("integer                       :: ieptr,ipos");
  com();
  com();
  writeSource("edatPtr           => firstEdatPtr");
  writeSource("isFirstDramaEdat  =  Oui");
  com();
  writeSource("edat_convert_loop: do");
  com();
  writeSource("  edatData =>edatPtr\%edatData");
  writeSource("  no     = edatData\%no");
  writeSource("  np     = edatData\%np");
  writeSource("  nelem  = edatData\%nelem");
  writeSource("  netype = edatData\%netype");
  com();
  writeSource("  allocate(dramaEdatData,dramaEdatPtr)");
  com();
  writeSource("  ! the edat no is the same for global/local edat");
  writeSource("  dramaEdatPtr\%no            =  no");
  writeSource("  dramaEdatData\%no           =  no");
  com();
  com();
  writeSource("  dramaEdatPtr\%dramaEdatData => dramaEdatData");
  writeSource("  nullify(dramaEdatPtr\%next)");
  com();
  writeSource("  if(isFirstDramaEdat .eq. Oui) then");
  writeSource("    firstDramaEdatPtr   => dramaEdatPtr");
  writeSource("    currentDramaEdatPtr => dramaEdatPtr");
  writeSource("    isFirstDramaEdat = Non");
  writeSource("  else");
  writeSource("    currentDramaEdatPtr\%next => dramaEdatPtr");
  writeSource("    currentDramaEdatPtr      => dramaEdatPtr");
  writeSource("  endif");
  com();
  writeSource("  if(edatPtr\%isRegion .eq. Oui) then");
  com();
  writeSource("    ! local EDAT");
  writeSource("    allocate(matno_new(myelem),enptr(2,myelem+1),con(2,myelem*np))");
  com();
  writeSource("    ! local edat = myelem");
  writeSource("    dramaEdatData\%nelem = myelem");
  com();
  writeSource("    dramaEdatData\%enptr =>enptr");
  writeSource("    dramaEdatData\%con   =>con");
  writeSource("    dramaEdatData\%matno =>matno_new");
  com();
  writeSource("    dramaEdatData\%netype = netype         ! P2 limit");
  com();
  writeSource("    ielem => edatData\%ielem");
  writeSource("    matno => edatData\%matno");
  com();
  writeSource("    ieptr = 0");
  writeSource("    ipos  = 1");
  writeSource("    do i=1,nelem");
  writeSource("      if(metis(i) .eq. mypeid) then");
  writeSource("        ieptr            = ieptr + 1");
  writeSource("        enptr(1,ieptr)   = ipos");
  writeSource("        enptr(2,ieptr)   = NUR_ONE_ETYPE");
  writeSource("        matno_new(ieptr) = matno(i)");
  com();
  writeSource("        do j=1,np");
  writeSource("          con(1,ipos+j-1) = loc(2,ielem(j,i))");
  writeSource("          con(2,ipos+j-1) = loc(1,ielem(j,i))");
  writeSource("        end do");
  writeSource("        ipos = ipos + np");
  writeSource("      end if");
  writeSource("    end do");
  com();
  com();
  com();
  writeSource("    if(myelem .ne. ieptr) then");
  writeSource("      write(*,*) 'error in making local enptr '");
  writeSource("      call abortexit(mypeid)");
  writeSource("    endif");
  com();
  writeSource("    ieptr          = ieptr + 1");
  writeSource("    enptr(1,ieptr) = ipos");
  com();
  com();
  writeSource("  else");
  com();
  com();
  writeSource("    ! global EDAT");
  writeSource("    allocate(matno_new(nelem) ,enptr(2,nelem+1) ,con(2,nelem*np))");
  com();
  writeSource("    dramaEdatData\%enptr =>enptr");
  writeSource("    dramaEdatData\%con   =>con");
  writeSource("    dramaEdatData\%matno =>matno_new");
  writeSource("    dramaEdatData\%nelem = nelem               ! Global edat");
  com();
  writeSource("    ielem => edatData\%ielem");
  writeSource("    matno => edatData\%matno");
  com();
  writeSource("    ieptr = 0");
  writeSource("    ipos  = 1");
  writeSource("    do i=1,nelem");
  writeSource("      ieptr            = ieptr + 1");
  writeSource("      enptr(1,ieptr)   = ipos");
  writeSource("      enptr(2,ieptr)   = NUR_ONE_ETYPE");
  writeSource("      matno_new(ieptr) = matno(i)");
  com();
  writeSource("      do j=1,np");
  writeSource("        con(1,ipos+j-1) = loc(2,ielem(j,i))");
  writeSource("        con(2,ipos+j-1) = loc(1,ielem(j,i))");
  writeSource("      end do");
  writeSource("      ipos = ipos + np");
  com();
  writeSource("    end do");
  com();
  writeSource("    ieptr          = ieptr + 1");
  writeSource("    enptr(1,ieptr) = ipos");
  com();
  writeSource("  endif");
  com();
  writeSource("  if(.not. associated(edatPtr\%next)) exit edat_convert_loop");
  writeSource("  edatPtr => edatPtr\%next");
  com();
  writeSource("end do edat_convert_loop");
  com();
  writeSource("end subroutine mkdramaedats");
  com();
  writeSource("subroutine mkdramansets(mypeid,nprocs,loc,npmax_g,       &");
  writeSource("                        firstNsetPtr,firstDramaNsetPtr )");
  writeSource("use numeric");
  writeSource("use femDataType");
  writeSource("use abortmodule");
  writeSource("implicit none");
  com();
  writeSource("integer                      :: mypeid,nprocs");
  writeSource("integer                      :: npmax_g");
  writeSource("integer,dimension(2,npmax_g) :: loc");
  com();
  writeSource("type(nsetList),pointer       :: firstNsetPtr");
  writeSource("type(dramaNsetList),pointer  :: firstDramaNsetPtr");
  com();
  writeSource("! auto variables");
  com();
  writeSource("integer                        :: i,j");
  writeSource("integer                        :: no,nodes,np");
  writeSource("integer,dimension(:,:),pointer :: inset");
  writeSource("integer,dimension(:,:),pointer :: con,info");
  writeSource("integer                        :: isFirstDramaNset");
  writeSource("integer                        :: ipt");
  com();
  writeSource("type(nsetList),pointer         :: nsetPtr");
  writeSource("type(nset)    ,pointer         :: nsetData");
  writeSource("type(dramaNsetList),pointer    :: dramaNsetPtr,currentDramaNsetPtr");
  writeSource("type(dramaNset),pointer        :: dramaNsetData");
  com();
  writeSource("!------------------------");
  writeSource("nsetPtr          => firstNsetPtr");
  writeSource("isFirstDramaNset =  Oui");
  com();
  writeSource("nset_convert_loop: do");
  writeSource("  nsetData => nsetPtr\%nsetData");
  writeSource("  no       =  nsetData\%no");
  writeSource("  np       =  nsetData\%np");
  writeSource("  nodes    =  nsetData\%nodes");
  com();
  com();
  writeSource("  allocate(dramaNsetData,dramaNsetPtr)");
  writeSource("  dramaNsetPtr\%dramaNsetData => dramaNsetData");
  writeSource("  dramaNsetPtr\%no            =  no");
  com();
  writeSource("  nullify(dramaNsetPtr\%next)");
  com();
  writeSource("  if(isFirstDramaNset .eq. Oui) then");
  writeSource("    firstDramaNsetPtr   => dramaNsetPtr");
  writeSource("    currentDramaNsetPtr => dramaNsetPtr");
  writeSource("    isFirstDramaNset    =  Non");
  writeSource("  else");
  writeSource("    currentDramaNsetPtr\%next  => dramaNsetPtr");
  writeSource("    currentDramaNsetPtr       => dramaNsetPtr");
  writeSource("  endif");
  com();
  writeSource("  allocate( con(2,nodes) )");
  writeSource("  dramaNsetData\%con    => con");
  com();
  writeSource("  if(np > 1) then");
  writeSource("    allocate( info(np-1,nodes) )");
  writeSource("    dramaNsetData\%info => info");
  writeSource("  else");
  writeSource("    nullify(dramaNsetData\%info)");
  writeSource("  endif");
  com();
  writeSource("  dramaNsetData\%no     =  no");
  writeSource("  dramaNsetData\%np     =  np-1             ! CAUTION!   np-1");
  writeSource("  dramaNsetData\%nodes  =  nodes");
  com();
  writeSource("  dramaNsetPtr\%no      =  no");
  com();
  writeSource("  inset => nsetData\%inset");
  com();
  writeSource("  do i=1,nodes");
  writeSource("   ipt = inset(1,i)");
  writeSource("   con(1,i) = loc(2,ipt)");
  writeSource("   con(2,i) = loc(1,ipt)");
  writeSource("  end do");
  com();
  writeSource("  if( np > 1) then");
  writeSource("    do i=1,nodes");
  writeSource("     do j=2,np");
  writeSource("       info(j-1,i) = inset(j,i)");
  writeSource("     end do");
  writeSource("    end do");
  writeSource("  endif");
  com();
  writeSource("  if( .not. associated(nsetPtr\%next)) exit nset_convert_loop");
  writeSource("  nsetPtr => nsetPtr\%next");
  writeSource("end do nset_convert_loop");
  com();
  writeSource("end subroutine mkdramansets");
  com();
  writeSource("subroutine mkdramaip(mypeid,nprocs,loc,npmax_g, &");
  writeSource("                     ipData,dramaIPData          )");
  writeSource("use femDataType");
  writeSource("use numeric");
  writeSource("implicit none");
  com();
  writeSource("integer                       :: mypeid,nprocs");
  writeSource("integer                       :: npmax_g");
  writeSource("integer,dimension(2,npmax_g)  :: loc");
  writeSource("type(ipdat),pointer           :: ipData");
  writeSource("type(dramaIP),pointer         :: dramaIPData");
  com();
  writeSource("! auto variables");
  writeSource("integer                       :: i");
  writeSource("integer                       :: nodes");
  writeSource("integer,dimension(:,:),pointer:: con");
  writeSource("integer,dimension(:),pointer  :: original");
  com();
  writeSource("nodes = ipData\%nodes");
  com();
  writeSource("allocate(dramaIPData,con(2,nodes),original(nodes))");
  com();
  writeSource("dramaIPData\%nodes    =  nodes");
  writeSource("dramaIPData\%con      => con");
  writeSource("dramaIPData\%original => original");
  com();
  writeSource("do i=1,nodes");
  writeSource("  original(i) = ipData\%ipno(i)");
  writeSource("  con(1,i)    = loc(2,original(i))");
  writeSource("  con(2,i)    = loc(1,original(i))");
  writeSource("end do");
  writeSource("end subroutine mkdramaip");
  com();
  writeSource("subroutine setdramaedat(edatno,firstDramaEdatPtr,nelem,enptr,con,matno,netype)");
  com();
  writeSource("use femDataType");
  writeSource("use numeric");
  writeSource("use abortmodule");
  writeSource("implicit none");
  com();
  writeSource("integer,intent(in)                        :: edatno");
  writeSource("type(dramaEdatList),pointer               :: firstDramaEdatPtr");
  writeSource("integer                                   :: nelem");
  writeSource("integer,dimension(:,:),pointer            :: enptr,con");
  writeSource("integer,dimension(:)  ,pointer            :: matno");
  writeSource("integer                                   :: netype");
  com();
  writeSource("! auto variable");
  writeSource("type(dramaEdatList),pointer    :: dramaEdatPtr");
  writeSource("type(dramaEdat),pointer        :: dramaEdatData");
  com();
  writeSource("!-----------------------------------------------------------");
  com();
  writeSource("nullify(enptr,con,matno)");
  com();
  writeSource("dramaEdatPtr => firstDramaEdatPtr");
  com();
  writeSource("search_loop: do");
  com();
  com();
  writeSource(" if(edatno .eq. dramaEdatPtr\%no) then");
  writeSource("   dramaEdatData => dramaEdatPtr\%dramaEdatData");
  writeSource("   enptr => dramaEdatData\%enptr");
  writeSource("   con   => dramaEdatData\%con");
  writeSource("   matno => dramaEdatData\%matno");
  writeSource("   nelem =  dramaEdatData\%nelem");
  com();
  writeSource("   netype=  dramaEdatData\%netype   ! P2 limit");
  com();
  writeSource("   exit search_loop");
  writeSource(" endif");
  com();
  writeSource(" if( .not. associated(dramaEdatPtr\%next)) exit search_loop");
  writeSource(" dramaEdatPtr => dramaEdatPtr\%next");
  com();
  writeSource("end do search_loop");
  com();
  writeSource("if( .not. associated(enptr)) then");
  writeSource("  write(*,*) 'edatno=',edatno , ' not found(dramaEdatModel)'");
  writeSource("  call abortexit(999)");
  writeSource("endif");
  com();
  writeSource("end subroutine setdramaedat");
  com();
  writeSource("subroutine setdramanset(nsetno,firstDramaNsetPtr,nodes,np,con,info)");
  com();
  writeSource("use femDataType");
  writeSource("use numeric");
  writeSource("use abortmodule");
  writeSource("implicit none");
  com();
  writeSource("integer,intent(in)                        :: nsetno");
  writeSource("type(dramaNsetList),pointer               :: firstDramaNsetPtr");
  writeSource("integer                                   :: nodes,np");
  writeSource("integer,dimension(:,:),pointer            :: con,info");
  com();
  writeSource("! auto variable");
  writeSource("type(dramaNsetList),pointer    :: dramaNsetPtr");
  writeSource("type(dramaNset),pointer        :: dramaNsetData");
  com();
  writeSource("!-----------------------------------------------------------");
  com();
  writeSource("nullify(con,info)");
  com();
  writeSource("dramaNsetPtr => firstDramaNsetPtr");
  com();
  writeSource("search_loop: do");
  com();
  writeSource(" if(nsetno .eq. dramaNsetPtr\%no) then");
  writeSource("   dramaNsetData => dramaNsetPtr\%dramaNsetData");
  writeSource("   con   => dramaNsetData\%con");
  writeSource("   info  => dramaNsetData\%info");
  writeSource("   nodes =  dramaNsetData\%nodes");
  writeSource("   np    =  dramaNsetData\%np");
  com();
  writeSource("   exit search_loop");
  writeSource(" endif");
  com();
  writeSource(" if( .not. associated(dramaNsetPtr\%next)) exit search_loop");
  writeSource(" dramaNsetPtr => dramaNsetPtr\%next");
  com();
  writeSource("end do search_loop");
  com();
  writeSource("if( .not. associated(con)) then");
  writeSource("  write(*,*) 'no=',nsetno , ' not found(setdramanset)'");
  writeSource("  call abortexit(999)");
  writeSource("endif");
  com();
  writeSource("end subroutine setdramanset");
  com();
  writeSource("!=================================");
  writeSource("end module dramaDataModel");

  // ORIGINAL SOURCE END-------------------

  CloseSource();

  return;
}
