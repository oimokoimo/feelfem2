/*
 *  feelfem version 1.0  Copyright(c)  NEC Corporation 1999,2000
 *                       Programmed by Hidehiro  FUJIO
 *
 *  Filename : SL_AMGCRS.cpp   (Source Library for AMGCRS.f90)
 *  Date     : 2000/11/20
 *  Modified : 2000/11/20
 *  
 *  Purpose  :
 *  
 */
#include "SL_feelfem90DRAMA.hpp"

void SL_feelfem90DRAMA::SL_AMGCRS(int makeFlag)
{
  char *sourceName;
  
  sourceName = GetSourceName("PAMGCRS");

  OpenSource(sourceName);
  StoreSource(sourceName,makeFlag);


  writeSource("module PAMGCRS");
  com();
  writeSource("contains");
  com();
  writeSource("subroutine pmkAMGCRShalo(nouter,ndno,peno,ipf_ex,ipd_ex,ipd_halo,sort) ");
  writeSource("integer,intent(in)          :: nouter");
  writeSource("integer,dimension(nouter)   :: ndno,peno,ipf_ex,ipd_ex");
  writeSource("integer,dimension(:),pointer:: ipd_halo,sort");
  com();
  writeSource("! auto variables");
  writeSource("integer                     :: i,j");
  com();
  writeSource("integer                     :: ip,jp");
  com();
  writeSource("integer                     :: ipt");
  com();
  writeSource("!-----------------");
  writeSource("!make sort array ");
  com();
  writeSource("allocate(sort(nouter))");
  writeSource("do i=1,nouter");
  writeSource(" sort(i) = i");
  writeSource("end do");
  com();
  writeSource("do i=1,nouter-1");
  writeSource(" ");
  writeSource(" ip = sort(i)");
  writeSource(" do j=i+1,nouter");
  writeSource("  jp = sort(j)");
  com();
  writeSource("  if(peno(jp) < peno(ip) .or. (peno(jp) == peno(ip) .and. ndno(jp) < ndno(ip)) ) then");
  writeSource("    sort(i) = jp");
  writeSource("    sort(j) = ip");
  writeSource("    ip = jp");
  writeSource("  end if");
  writeSource(" end do");
  writeSource("end do");
  com();
  writeSource("!---");
  writeSource("allocate(ipd_halo(nouter))");
  writeSource("ipt = 1");
  writeSource("do i=1,nouter");
  writeSource("  ipd_halo(sort(i)) = ipt");
  writeSource("  ipt = ipt + ipf_ex(sort(i))");
  writeSource("end do");
  com();
  writeSource("!--");
  writeSource("!do i=1,nouter");
  writeSource("!write(*,*) 'i=',i,'  pe,nd=',peno(sort(i)),ndno(sort(i))");
  writeSource("!end do");
  com();
  writeSource("!do i=1,nouter");
  writeSource("!write(*,*) 'i=',i,' pe,nd,ipd_halo=',peno(i),ndno(i),ipd_halo(i)");
  writeSource("!end do");
  writeSource("  ");
  writeSource("  ");
  writeSource("end subroutine pmkAMGCRShalo");
  com();
  writeSource("subroutine pmkAMGCRSupdate(myrank,nprocs,mypeid,           &");
  writeSource("                           neq,nhalo,isumup,               &");
  writeSource("                           ndno,peno,nouter,               &");
  writeSource("                           ipf_ex,ipd_ex,ipd_halo,sort_ex, &");
  writeSource("                           iptrcol,indrow,ncof,            &");
  writeSource("                           penv,pupdate,glinfo             )");
  com();
  writeSource("use mod_amg_update");
  writeSource("use mod_amg_penv");
  com();
  writeSource("implicit none");
  com();
  writeSource("integer                      :: myrank,nprocs,mypeid");
  writeSource("integer                      :: neq,nhalo");
  writeSource("integer,dimension(:)         :: isumup");
  writeSource("integer                      :: nouter");
  writeSource("integer,dimension(nouter)    :: ndno,peno,ipf_ex,ipd_ex,ipd_halo");
  writeSource("integer,dimension(:),pointer :: sort_ex");
  writeSource("integer,dimension(:)         :: iptrcol,indrow");
  writeSource("integer                      :: ncof");
  com();
  writeSource("type (amg_penv),       pointer :: penv");
  writeSource("type (amg_update_info),pointer :: pupdate");
  writeSource("type (amg_global_info),pointer :: glinfo   ");
  com();
  writeSource("! auto variables");
  writeSource("integer                        :: i,j,k ");
  writeSource("integer                        :: ipt");
  writeSource("integer,dimension(nhalo)       :: ienum,iproc   ! for pinput2amg routine");
  com();
  writeSource("integer                        :: nnuglobal");
  writeSource("integer                        :: myi");
  writeSource("integer,dimension(:),pointer   :: partition");
  com();
  writeSource("!----------------------------------------------------------");
  writeSource("k = 0");
  writeSource("do i=1,nouter");
  writeSource(" ipt = sort_ex(i)");
  writeSource(" do j=1,ipf_ex(ipt)");
  writeSource("  k=k+1");
  writeSource("  iproc(k) = peno(ipt) + 1");
  writeSource("  ienum(k) = isumup(peno(ipt)+1)+ipd_ex(ipt)+(j-1)");
  writeSource(" end do");
  writeSource("end do");
  com();
  writeSource("nnuglobal = isumup(nprocs+1)");
  com();
  com();
  writeSource("allocate(partition(nnuglobal))");
  writeSource("do i=1,nprocs");
  writeSource("do j=isumup(i)+1,isumup(i+1)");
  writeSource(" partition(j) = i-1");
  writeSource("end do");
  writeSource("end do");
  com();
  writeSource("myi = myrank + 1");
  com();
  writeSource("call amg_pinput2amg(penv,pupdate,glinfo, &");
  writeSource("                    myi,nprocs,MPI_COMM_WORLD,neq,nhalo, &");
  writeSource("                    ienum,iproc,                              &");
  writeSource("                    iptrcol,indrow,ncof,partition,nnuglobal   )");
  com();
  writeSource("deallocate( partition )");
  writeSource("deallocate( sort_ex   )");
  com();
  writeSource("end subroutine pmkAMGCRSupdate");
  com();
  com();
  writeSource("subroutine pmkAMGCRSindex(mypeid,nprocs,                &");
  writeSource("                          neq,isumup,                   &");
  writeSource("                          ndfmax,ncon,                  &");
  writeSource("                          ipf,ipd,npmax,                &");
  writeSource("                          ndno,peno,nouter,             & ");
  writeSource("                          ipf_ex,ipd_ex,ipd_halo,       &");
  writeSource("                          enptr   ,con   ,nelem   ,     &");
  writeSource("                          enptr_ex,con_ex,nelem_ex,     &");
  writeSource("                          iptrcol,indrow,ncof,nhalo     )");
  writeSource("                           ");
  writeSource("! ---");
  writeSource("! construct AMG/CRS matrix index");
  writeSource("! ");
  writeSource("!");
  writeSource("!");
  com();
  writeSource("use numeric");
  writeSource("use subSolveDrama");
  writeSource("implicit none");
  writeSource("                          ");
  writeSource("integer, intent(in)          :: mypeid,nprocs");
  writeSource("integer, intent(in)          :: neq            ! number of freedom of my PE");
  writeSource("integer, dimension(nprocs)   :: isumup");
  com();
  writeSource("integer, intent(in)          :: ndfmax         ! Maximum freedom in one element");
  writeSource("integer, intent(in)          :: ncon           ! Maximum relating freedom to ");
  writeSource("                                               ! one node  ");
  com();
  writeSource("integer, intent(in)                    :: npmax   ");
  writeSource("integer, intent(in),dimension(npmax)   :: ipf,ipd");
  writeSource("integer, intent(in)                    :: nouter");
  writeSource("integer, dimension(nouter)             :: ndno,peno,ipf_ex,ipd_ex");
  writeSource("integer, dimension(nouter)             :: ipd_halo");
  com();
  writeSource("integer, intent(in)                    :: nelem");
  writeSource("integer, dimension(:,:)                :: enptr,con");
  writeSource("integer, intent(in)                    :: nelem_ex");
  writeSource("integer, dimension(:,:)                :: enptr_ex,con_ex");
  com();
  writeSource("integer, dimension(:),pointer          :: iptrcol,indrow   ! allocate here");
  writeSource("integer                                :: ncof,nhalo");
  com();
  com();
  writeSource("! auto variables");
  writeSource("integer                         :: i, j, k,l");
  writeSource("integer                         ::   nj,nk");
  writeSource("integer                         :: ipos_from,ipos_to");
  writeSource("integer,dimension(:,:),pointer  :: ic        ! allocate(ncon,neq)");
  writeSource("                                             ! column index array(for indrow)");
  com();
  writeSource("integer,dimension(:),pointer    :: ip        ! allocate(neq)");
  writeSource("                                             ! row index array(for iptrcol)");
  writeSource("                                             ! it does not include the first");
  writeSource("                                             ! diagonal element, so it is not");
  writeSource("                                             ! the same of pmkCRSindex's ip");
  writeSource("                                             ! former ip(*)-1 = this ip(*)");
  com();
  writeSource("integer,dimension(ndfmax)       :: ipt       ! equation number list for one ");
  writeSource("                                             ! element");
  writeSource("integer,dimension(ndfmax)       :: ipno      ! local equation number list");
  writeSource("                                             ! only for local rows ");
  com();
  writeSource("integer                         :: iptr      ! pointer");
  writeSource("integer                         :: iptr_ipno ! pointer");
  com();
  writeSource("integer                         :: nd,pe     ! node number / pe number");
  com();
  writeSource("integer                         :: exno      ! external list number");
  com();
  writeSource("!======================================================================");
  writeSource("! allocate ip(neq),ic(ncon,neq)");
  writeSource("!");
  writeSource("allocate( ip(neq) )");
  writeSource("allocate( ic(ncon,neq) )     ! Huge array");
  com();
  writeSource("do i=1,neq ");
  writeSource(" ip(i)   = 1                 ! AMGCRS (first element is always diagonal)");
  writeSource(" ic(1,i) = i                 ! AMGCRS (local column number for local equations)");
  writeSource("end do");
  com();
  com();
  writeSource("! Construct ic array");
  com();
  writeSource("!-----------");
  writeSource("! My element");
  writeSource("!-----------");
  writeSource("do i=1,nelem");
  com();
  writeSource("!-------------------------------------------");
  writeSource("! step 1");
  writeSource("! make equation number list for i-th element");
  writeSource("!-------------------------------------------");
  writeSource("  iptr      = 0");
  writeSource("  iptr_ipno = 0");
  writeSource("  ipos_from = enptr(1,i  )");
  writeSource("  ipos_to   = enptr(1,i+1)-1");
  writeSource(" ");
  writeSource("  do j=ipos_from,ipos_to");
  writeSource("   nd = con(1,j)");
  writeSource("   pe = con(2,j)");
  com();
  writeSource("   if(pe .eq. mypeid) then");
  com();
  writeSource("     do k=1,ipf(nd)");
  writeSource("      iptr = iptr + 1");
  writeSource("      ipt(iptr) = ipd(nd) + (k-1)        ! AMG/CRS is LOCAL NUMBER");
  com();
  writeSource("      iptr_ipno       = iptr_ipno + 1");
  writeSource("      ipno(iptr_ipno) = ipd(nd) + (k-1)  ! Row number list(local number)");
  writeSource("                                         ! both for AMGCRS and AchimCRS");
  com();
  writeSource("     end do");
  com();
  writeSource("   else");
  com();
  writeSource("     exno = ndsearch_ex(nd,pe,ndno,peno,nouter)");
  writeSource("     do k=1,ipf_ex(exno)");
  writeSource("       iptr = iptr + 1");
  writeSource("       ipt(iptr) = neq+ipd_halo(exno)+(k-1)    ! AMG/CRS halo no global ");
  writeSource("     end do ");
  com();
  writeSource("   endif   ! if(pe .eq. mypeid)");
  com();
  writeSource("  end do  ! do j=ipos_from,ipos_to");
  com();
  writeSource("! construct ic,ip");
  com();
  writeSource("  do j=1,iptr_ipno     !iptr_ipno has the number of rows for my PE");
  writeSource("    nj = ipno(j)");
  com();
  writeSource("    do k=1,iptr        ! for all concerning columns");
  com();
  writeSource("      nk = ipt(k)      ! matrix cofficient is (nj,nk)");
  com();
  writeSource("      do l=1,ip(nj)");
  writeSource("        if(ic(l,nj) .eq. nk) goto 255");
  writeSource("      end do");
  writeSource("      ");
  writeSource("      ip(nj)        = ip(nj) + 1");
  writeSource("      ic(ip(nj),nj) = nk  ");
  com();
  writeSource("255   continue");
  com();
  writeSource("    end do  ! k=1,iptr      (column : all         )");
  writeSource("  end do    ! j=1,iptr_no   (row    : only my PE's)");
  com();
  writeSource("end do   ! do i=1,nelem    end of my element loop");
  com();
  com();
  writeSource("!----------------");
  writeSource("! Other's element");
  writeSource("!----------------");
  writeSource("do i=1,nelem_ex");
  com();
  writeSource("!-------------------------------------------");
  writeSource("! step 1");
  writeSource("! make equation number list for i-th element");
  writeSource("!-------------------------------------------");
  writeSource("  iptr      = 0");
  writeSource("  iptr_ipno = 0");
  writeSource("  ipos_from = enptr_ex(1,i  )");
  writeSource("  ipos_to   = enptr_ex(1,i+1)-1");
  writeSource(" ");
  writeSource("  do j=ipos_from,ipos_to");
  writeSource("   nd = con_ex(1,j)");
  writeSource("   pe = con_ex(2,j)");
  com();
  writeSource("   if(pe .eq. mypeid) then");
  com();
  writeSource("     do k=1,ipf(nd)");
  writeSource("      iptr = iptr + 1");
  writeSource("      ipt(iptr) = ipd(nd) + (k-1)    ! AMG/CRS is LOCAL NUMBER");
  com();
  writeSource("      iptr_ipno       = iptr_ipno + 1");
  writeSource("      ipno(iptr_ipno) = ipd(nd) + (k-1)  ! Row number list(local number)");
  writeSource("                                         ! both for AMGCRS and AchimCRS");
  com();
  writeSource("     end do");
  com();
  writeSource("   else");
  com();
  writeSource("     exno = ndsearch_ex(nd,pe,ndno,peno,nouter)");
  writeSource("     do k=1,ipf_ex(exno)");
  writeSource("       iptr      = iptr + 1");
  writeSource("       ipt(iptr) = neq + (ipd_halo(exno)+(k-1))  ! AMG/CRS halo no.");
  writeSource("     end do ");
  com();
  writeSource("   endif   ! if(pe .eq. mypeid)");
  com();
  writeSource("  end do  ! do j=ipos_from,ipos_to");
  com();
  writeSource("! construct ic,ip");
  com();
  writeSource("  do j=1,iptr_ipno     !iptr_ipno has the number of rows for my PE");
  writeSource("    nj = ipno(j)");
  com();
  writeSource("    do k=1,iptr        ! for all concerning columns");
  com();
  writeSource("      nk = ipt(k)      ! matrix cofficient is (nj,nk)");
  com();
  writeSource("      do l=1,ip(nj)");
  writeSource("        if(ic(l,nj) .eq. nk) goto 355");
  writeSource("      end do");
  writeSource("      ");
  writeSource("      ip(nj)        = ip(nj) + 1");
  writeSource("      ic(ip(nj),nj) = nk  ");
  com();
  writeSource("355   continue");
  com();
  writeSource("    end do  ! k=1,iptr      (column : all         )");
  writeSource("  end do    ! j=1,iptr_no   (row    : only my PE's)");
  com();
  writeSource("end do   ! do i=1,nelem_ex   end of my element loop");
  com();
  com();
  writeSource("!--------------------------");
  writeSource("! Make indrow,iptrcol");
  writeSource("!--------------------------");
  writeSource("allocate( iptrcol(neq+1))");
  writeSource("iptrcol(1) = 1                     ! ");
  writeSource("ncof      = 0");
  com();
  writeSource("do i=1,neq");
  writeSource(" iptrcol(i+1) = iptrcol(i)+ip(i)");
  writeSource(" ncof         = ncof      +ip(i)");
  writeSource("end do");
  com();
  writeSource("allocate( indrow(ncof) )");
  writeSource("do i=1,neq");
  writeSource("  do j=1,ip(i)");
  writeSource("    indrow( iptrcol(i) + (j-1)) = ic(j,i)");
  writeSource("  end do");
  writeSource("end do");
  com();
  writeSource("deallocate(ip,ic)");
  com();
  writeSource("!------------------");
  writeSource("! nhalo calculation");
  writeSource("!------------------");
  writeSource("nhalo = 0");
  writeSource("do i=1,nouter");
  writeSource("  nhalo = nhalo + ipf_ex(i)");
  writeSource("end do");
  com();
  writeSource("end subroutine pmkAMGCRSindex");
  com();
  writeSource("end module PAMGCRS");
         
  CloseSource();

  return;
}
