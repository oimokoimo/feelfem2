/*
 *  feelfem version 1.0  Copyright(c)  NEC Corporation 1999,2000
 *                       Programmed by Hidehiro  FUJIO
 *
 *  Filename : SL_datatrans.cpp
 *  Date     : 2000/11/21
 *  Modified : 2000/11/21
 *  
 *  Purpose  : datatrans.f90 routine
 *  
 */
#include "SL_feelfem90DRAMA.hpp"

void SL_feelfem90DRAMA::SL_datatrans(int makeFlag)
{
  char *sourceName;
  
  sourceName = GetSourceName("datatrans");
  OpenSource(sourceName);
  StoreSource(sourceName,makeFlag);

  writeSource("module datatrans");
  com();
  com();
  writeSource("contains");
  com();
  writeSource("subroutine initbcast(myrank,nprocs,                                     &");
  writeSource("                     ndim,npmax,npmax_g,nelem_g,nedat,nnset,nnum,nip,   &");
  writeSource("                     mode_ex,mode_output,nvars_fem,nvars_ewise,         &");
  writeSource("                     x,y,                                               &");
  writeSource("                     firstEdatPtr,firstNsetPtr,ipData,                  &");
  writeSource("                     metis                                               ) ");
  writeSource("use numeric");
  writeSource("use femDataType");
  com();
  writeSource("implicit none");
  com();
  writeSource("include 'mpif.h'");
  com();
  writeSource("! feel_dat fundamental parameters");
  writeSource("integer                        :: myrank,nprocs");
  com();
  com();
  writeSource("integer(kind=INT4 )            :: ndim             ! space dimension");
  writeSource("integer(kind=INT4 )            :: npmax            ! nodes(global/local)");
  writeSource("integer(kind=INT4 )            :: npmax_g");
  writeSource("integer(kind=INT4 )            :: nelem_g          ! number of region element");
  writeSource("integer(kind=INT4 )            :: nedat");
  writeSource("integer(kind=INT4 )            :: nnset");
  writeSource("integer(kind=INT4 )            :: nnum");
  writeSource("integer(kind=INT4 )            :: nip");
  com();
  writeSource("integer(kind=INT4 )            :: mode_ex");
  writeSource("integer(kind=INT4 )            :: mode_output");
  writeSource("integer(kind=INT4 )            :: nvars_fem,nvars_ewise");
  com();
  writeSource("real   (kind=REAL8),dimension(:),pointer :: x,y");
  com();
  writeSource("type(edatList),pointer         :: firstEdatPtr");
  writeSource("type(nsetList),pointer         :: firstNsetPtr");
  writeSource("type(ipdat),   pointer         :: ipData");
  com();
  writeSource("integer,dimension(:),pointer   :: metis");
  writeSource("!-----------------------");
  writeSource("! Auto variable");
  writeSource("!-----------------------");
  writeSource("integer                        :: i");
  writeSource("integer                        :: ierror");
  com();
  writeSource("! ------------");
  writeSource("! EDAT/NSET/IP");
  writeSource("! ------------");
  writeSource("integer                        :: no");
  writeSource("integer                        :: np");
  com();
  writeSource("! ----");
  writeSource("! EDAT");
  writeSource("! ----");
  writeSource("type(edat), pointer            :: edatData");
  writeSource("type(edatList),pointer         :: currentEdatPtr,edatPtr");
  com();
  writeSource("integer(kind=INT4 )            :: netype");
  writeSource("integer,dimension(:,:),pointer :: ielem             ! for reading");
  writeSource("integer,dimension(:)  ,pointer :: matno             ! for reading");
  com();
  writeSource("integer                        :: nelem");
  com();
  writeSource("! ----");
  writeSource("! NSET");
  writeSource("! ----");
  writeSource("type(nset), pointer            :: nsetData");
  writeSource("type(nsetList),pointer         :: currentNsetPtr,nsetPtr");
  com();
  writeSource("integer,dimension(:,:),pointer :: inset");
  writeSource("integer                        :: nodes");
  com();
  com();
  writeSource("! ----");
  writeSource("! IP");
  writeSource("! ----");
  writeSource("integer,dimension(:),pointer   :: ipno                        ");
  com();
  com();
  com();
  writeSource("!-----------------------");
  writeSource("! Message passing");
  writeSource("!-----------------------");
  writeSource("call MPI_BCAST(ndim   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  writeSource("call MPI_BCAST(npmax  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  writeSource("call MPI_BCAST(nelem_g,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  writeSource("call MPI_BCAST(nedat  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  writeSource("call MPI_BCAST(nnset  ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  writeSource("call MPI_BCAST(nnum   ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  writeSource("call MPI_BCAST(nip    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  writeSource("call MPI_BCAST(mode_ex,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  writeSource("call MPI_BCAST(mode_output,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  writeSource("call MPI_BCAST(nvars_fem,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  writeSource("call MPI_BCAST(nvars_ewise,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  com();
  writeSource("! parallel");
  writeSource("npmax_g = npmax");
  com();
  writeSource("! NODE");
  writeSource("if(myrank .ne. 0) then");
  writeSource("  allocate(x(npmax),y(npmax))");
  writeSource("endif");
  writeSource("call MPI_BCAST(x   ,npmax,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ierror)");
  writeSource("call MPI_BCAST(y   ,npmax,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ierror)");
  com();
  writeSource("! EDAT");
  com();
  writeSource("do i=1,nedat");
  writeSource(" if(myrank .eq. 0) then");
  writeSource("   if(i .eq. 1) then");
  writeSource("    edatPtr => firstEdatPtr");
  writeSource("   else");
  writeSource("    edatPtr => edatPtr%next");
  writeSource("   endif");
  com();
  writeSource("   edatData =>edatPtr%edatData");
  com();
  writeSource("   no     = edatData%no");
  writeSource("   nelem  = edatData%nelem");
  writeSource("   np     = edatData%np");
  writeSource("   netype = edatData%netype");
  writeSource(" endif");
  com();
  writeSource(" call MPI_BCAST(no    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  writeSource(" call MPI_BCAST(nelem ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  writeSource(" call MPI_BCAST(np    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  writeSource(" call MPI_BCAST(netype,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  com();
  writeSource(" if(myrank .eq. 0) then");
  com();
  writeSource("   ielem => edatData%ielem");
  writeSource("   matno => edatData%matno");
  com();
  writeSource(" else");
  com();
  writeSource("   allocate(edatData,edatPtr,ielem(np,nelem),matno(nelem))");
  com();
  writeSource("   edatData%ielem => ielem");
  writeSource("   edatData%matno => matno");
  writeSource("   edatData%no    =  no");
  writeSource("   edatData%np    =  np");
  writeSource("   edatData%nelem =  nelem");
  writeSource("   edatData%netype=  netype");
  com();
  writeSource("   edatPtr%no       =  no");
  writeSource("   edatPtr%edatData => edatData ");
  writeSource("   nullify(edatPtr%next)");
  com();
  writeSource("   if(i .eq. 1) then");
  writeSource("    firstEdatPtr=>edatPtr");
  writeSource("    currentEdatPtr=>edatPtr");
  writeSource("   else");
  writeSource("    currentEdatPtr%next =>edatPtr");
  writeSource("    currentEdatPtr      =>edatPtr");
  writeSource("   endif");
  writeSource(" endif");
  com();
  writeSource(" call MPI_BCAST(ielem,np*nelem,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  writeSource(" call MPI_BCAST(matno,   nelem,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  writeSource(" end do");
  com();
  com();
  writeSource("! NSET");
  com();
  writeSource("do i=1,nnset");
  writeSource(" if(myrank .eq. 0) then");
  writeSource("  if(i .eq. 1) then");
  writeSource("    nsetPtr => firstNsetPtr");
  writeSource("  else");
  writeSource("    nsetPtr => nsetPtr%next");
  writeSource("  endif");
  com();
  writeSource("  nsetData => nsetPtr%nsetData");
  com();
  writeSource("  no   = nsetData%no");
  writeSource("  np   = nsetData%np");
  writeSource("  nodes= nsetData%nodes");
  writeSource(" endif");
  com();
  writeSource(" call MPI_BCAST(no    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  writeSource(" call MPI_BCAST(np    ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  writeSource(" call MPI_BCAST(nodes ,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  com();
  writeSource(" if(myrank .eq. 0 ) then");
  com();
  writeSource("  inset => nsetData%inset");
  com();
  writeSource(" else");
  com();
  writeSource("  allocate(nsetData,nsetPtr,inset(np,nodes))");
  writeSource("  nsetData%inset => inset");
  writeSource("  nsetData%no    =  no");
  writeSource("  nsetData%np    =  np");
  writeSource("  nsetData%nodes =  nodes");
  com();
  writeSource("  nsetPtr%no     =  no");
  writeSource("  nsetPtr%nsetData => nsetData");
  writeSource("  nullify(nsetPtr%next)");
  com();
  writeSource("  if(i .eq. 1) then");
  writeSource("   firstNsetPtr =>nsetPtr");
  writeSource("   currentNsetPtr=>nsetPtr");
  writeSource("  else");
  writeSource("   currentNsetPtr%next =>nsetPtr");
  writeSource("   currentNsetPtr      =>nsetPtr");
  writeSource("  endif");
  writeSource(" endif");
  writeSource(" ");
  writeSource(" call MPI_BCAST(inset ,np*nodes,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  com();
  writeSource(" end do");
  com();
  writeSource("! IP");
  writeSource(" if(nip .ne. 0) then");
  writeSource("  if(myrank .eq. 0) then");
  writeSource("    ipno => ipData%ipno");
  writeSource("  else");
  writeSource("    allocate(ipData,ipno(nip))");
  writeSource("    ipData%ipno  => ipno");
  writeSource("    ipData%nodes =  nip");
  writeSource("  endif");
  writeSource("  call MPI_BCAST(ipno,nip,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  writeSource(" endif");
  com();
  writeSource("! Metis");
  writeSource(" if(myrank .ne. 0) then");
  writeSource("   allocate(metis(nelem_g))");
  writeSource(" endif");
  writeSource(" call MPI_BCAST(metis,nelem_g,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  com();
  com();
  writeSource("end subroutine initbcast");
  com();
  writeSource("end module datatrans");

  CloseSource();

  return;
}
