/*
 *  feelfem version 1.0  Copyright(c)  NEC Corporation 1999,2000
 *                       Programmed by Hidehiro  FUJIO
 *
 *  Filename : SL_feelfem90mp.cpp
 *  Date     : 2000/11/21
 *  Modified : 2000/11/21
 *  
 *  Purpose  : feelfem90mp.f90 routine
 *  
 */
#include "SL_feelfem90DRAMA.hpp"

void SL_feelfem90DRAMA::SL_feelfem90mp(int makeFlag)
{
  char *sourceName;
  
  sourceName = GetSourceName("feelfem90mp");
  OpenSource(sourceName);
  StoreSource(sourceName,makeFlag);

  writeSource("module feelfem90mp");
  writeSource("!--------------------------------------------------------");
  writeSource("! Message passing sub module for feelfem90");
  writeSource("!");
  writeSource("! subroutine ff90gathervbcast    ! for 1-dimensional array");
  writeSource("! subroutine ff90gathervbcast2   ! for 2-dimensional array");
  writeSource("!                                ! counts,displs are divided by np");
  writeSource("!");
  writeSource("!");
  writeSource("!--------------------------------------------------------");
  com();
  writeSource("contains");
  writeSource("subroutine ff90allgather(myrank,nprocs,count,mybuf,buf   )");
  writeSource("!");
  writeSource("! allocate receive buffer and calls mpi_allgather");
  writeSource("!");
  writeSource("use abortmodule");
  writeSource("implicit none");
  writeSource("!");
  writeSource("include 'mpif.h'");
  writeSource("!");
  writeSource("integer,intent(in)           :: myrank,nprocs");
  writeSource("integer,intent(in)           :: count");
  writeSource("integer,dimension(:)         :: mybuf");
  writeSource("integer,dimension(:),pointer :: buf              ! allocate here");
  com();
  writeSource("!auto variable");
  writeSource("integer                      :: ierror");
  com();
  com();
  com();
  writeSource("if(count .le. 0) then");
  writeSource("  write(*,*) '[ff90allgather] count =',count");
  writeSource("  call abortexit(myrank)");
  writeSource("endif");
  com();
  writeSource("allocate(buf(nprocs*count))");
  writeSource("call MPI_ALLGATHER(mybuf,count,MPI_INTEGER,               &");
  writeSource("                   buf  ,count,MPI_INTEGER,MPI_COMM_WORLD,ierror)");
  com();
  writeSource("!");
  writeSource("end subroutine ff90allgather");
  com();
  writeSource("subroutine ff90gathervbcast(myrank,nprocs,mycount,mybuf, &");
  writeSource("                            buf,counts,displs            )");
  writeSource("use abortmodule");
  writeSource("implicit none");
  writeSource("!");
  writeSource("include 'mpif.h'");
  writeSource("!");
  writeSource("integer,intent(in)           :: myrank,nprocs");
  writeSource("integer,intent(in)           :: mycount");
  writeSource("integer,dimension(:),pointer :: mybuf");
  writeSource("integer,dimension(:),pointer :: buf              ! allocate here");
  writeSource("integer,dimension(:),pointer :: counts           ! allocate here");
  writeSource("integer,dimension(:),pointer :: displs           ! allocate here ");
  com();
  writeSource("! auto variables");
  com();
  writeSource("integer                      :: i                ! for loop counter");
  writeSource("integer                      :: idisp,nwords     ! for counting");
  writeSource("integer                      :: ierror");
  com();
  com();
  writeSource("!------");
  com();
  com();
  writeSource("if(mycount < 0) then");
  writeSource("  write(*,*) '[ff90gathervbcast] myrank=',myrank,' mycount=',mycount");
  writeSource("  call abortexit(myrank)");
  writeSource("endif");
  com();
  writeSource("!if(mycount == 0) then");
  writeSource("!  allocate(sendbuffer(2))");
  writeSource("!else");
  writeSource("!  sendbuffer = mybuf");
  writeSource("!endif ");
  com();
  com();
  writeSource("allocate(counts(nprocs),displs(nprocs))");
  com();
  writeSource("call MPI_GATHER(mycount,   1, MPI_INTEGER,         &");
  writeSource("                counts ,   1, MPI_INTEGER, 0,      &");
  writeSource("                              MPI_COMM_WORLD,ierror)");
  writeSource("!----");
  writeSource("! now only PE0 has counts(*) array");
  writeSource("!----");
  com();
  writeSource("if(myrank .eq. 0) then");
  writeSource("  idisp = 0");
  writeSource("  do i=1,nprocs");
  writeSource("    displs(i) = idisp");
  writeSource("    idisp = idisp + counts(i)");
  writeSource("  end do");
  writeSource("  nwords = idisp");
  writeSource("endif");
  com();
  writeSource("!---");
  writeSource("! now only PE0 has displs(*) array");
  writeSource("!---");
  com();
  writeSource("! scatter buffer size nwords");
  writeSource("call MPI_BCAST(nwords,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  com();
  writeSource("!allocate recieve buffer in each processor");
  writeSource("allocate(buf(nwords))");
  com();
  writeSource("! scatter counts/displs array");
  writeSource("call MPI_BCAST(counts,nprocs,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  writeSource("call MPI_BCAST(displs,nprocs,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  com();
  writeSource("! gather and scatter data");
  com();
  writeSource("call MPI_GATHERV(mybuf,mycount,MPI_INTEGER,buf,counts,displs, &");
  writeSource("                               MPI_INTEGER,  0,MPI_COMM_WORLD,ierror)");
  writeSource("call MPI_BCAST(buf,nwords,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  com();
  com();
  writeSource("!if(mycount == 0) then ");
  writeSource("! deallocate(sendbuffer)");
  writeSource("!endif ");
  com();
  writeSource("end subroutine ff90gathervbcast");
  com();
  com();
  writeSource("subroutine ff90gathervbcast2(myrank,nprocs,np,n,mybuf, &");
  writeSource("                             buf,counts,displs            )");
  writeSource("!");
  writeSource("!  counts,displs are divided by np for 2-dimensional array");
  writeSource("!");
  writeSource("!");
  writeSource("!");
  writeSource("use abortmodule");
  writeSource("implicit none");
  writeSource("!");
  writeSource("include 'mpif.h'");
  writeSource("!");
  writeSource("integer,intent(in)              :: myrank,nprocs");
  writeSource("integer,intent(in)              :: np,n");
  writeSource("integer,dimension(:,:) ,pointer :: mybuf");
  writeSource("integer,dimension(:,:) ,pointer :: buf              ! allocate here");
  com();
  writeSource("integer,dimension(:)   ,pointer :: counts           ! allocate here");
  writeSource("integer,dimension(:)   ,pointer :: displs           ! allocate here ");
  com();
  writeSource("! auto variables");
  com();
  writeSource("integer                      :: i                ! for loop counter");
  writeSource("integer                      :: idisp,nwords     ! for counting");
  writeSource("integer                      :: ntimes");
  writeSource("integer                      :: mycount");
  writeSource("integer                      :: ierror");
  com();
  writeSource("!integer,dimension(:,:) ,pointer :: sendbuffer       ! for PGI ");
  writeSource("!integer,dimension(2,1)          :: tempbuffer");
  com();
  writeSource("!------");
  com();
  writeSource("mycount = np * n");
  com();
  writeSource("if(mycount < 0) then");
  writeSource("  write(*,*) '[ff90gathervbcast2] myrank=',myrank,' np=',np,' n=',n");
  writeSource("  call abortexit(myrank)");
  writeSource("endif");
  com();
  writeSource("!if(mycount == 0) then");
  writeSource("!  sendbuffer = mybuf");
  writeSource("!else");
  writeSource("!  allocate(sendbuffer(2,1))");
  writeSource("!endif ");
  com();
  com();
  writeSource("allocate(counts(nprocs),displs(nprocs))");
  com();
  writeSource("call MPI_GATHER(mycount,   1, MPI_INTEGER,         &");
  writeSource("                counts ,   1, MPI_INTEGER, 0,      &");
  writeSource("                              MPI_COMM_WORLD,ierror)");
  writeSource("!----");
  writeSource("! now only PE0 has counts(*) array");
  writeSource("!----");
  com();
  writeSource("if(myrank .eq. 0) then");
  writeSource("  idisp = 0");
  writeSource("  do i=1,nprocs");
  writeSource("    displs(i) = idisp");
  writeSource("    idisp = idisp + counts(i)");
  writeSource("  end do");
  writeSource("  nwords = idisp");
  writeSource("endif");
  com();
  writeSource("!---");
  writeSource("! now only PE0 has displs(*) array");
  writeSource("!---");
  com();
  writeSource("! scatter buffer size nwords");
  writeSource("call MPI_BCAST(nwords,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  com();
  writeSource("!allocate recieve buffer in each processor");
  writeSource("ntimes = nwords / np");
  com();
  writeSource("if(ntimes * np  .ne. nwords) then");
  writeSource(" write(*,*) 'calculation of ntimes illegal'");
  writeSource(" call abortexit(myrank)");
  writeSource("endif");
  writeSource(" ");
  writeSource("allocate(buf(np,ntimes))");
  com();
  com();
  writeSource("! scatter counts/displs array");
  writeSource("call MPI_BCAST(counts,nprocs,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  writeSource("call MPI_BCAST(displs,nprocs,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  com();
  writeSource("! gather and scatter data");
  writeSource("call MPI_GATHERV(mybuf,mycount,MPI_INTEGER,buf,counts,displs, &");
  writeSource("                               MPI_INTEGER,  0,MPI_COMM_WORLD,ierror)");
  writeSource("call MPI_BCAST(buf,nwords,MPI_INTEGER,0,MPI_COMM_WORLD,ierror)");
  com();
  writeSource("! Adjust for counts/displs for 2-dimensional array");
  writeSource("do i=1,nprocs");
  writeSource(" counts(i)=counts(i)/np");
  writeSource(" displs(i)=displs(i)/np");
  writeSource("end do");
  com();
  com();
  writeSource("end subroutine ff90gathervbcast2");
  writeSource("end module feelfem90mp");

  CloseSource();
  return;
}
