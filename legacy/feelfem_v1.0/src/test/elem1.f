      subroutine elem1(mypeid,nprocs,
     $  isumup,myeqfrom,myeqto,neqtotal,
     $  enptr,con,nelem,
     $  x,y,ipf,ipd,npmax,
     $  fem_v,
     $  enptr_ex,con_ex,nelem_ex,
     $  nouter,ndno,peno,x_ex,y_ex,ipfex,ipdex,
     $     femex_v,
     $ valmat,vfg,indrow,iptrcol,neq,ncof)
*------------------------------------------------------------
* Generated by feelfem Copyright(c) 1999-2001 NEC Corporation
*------------------------------------------------------------
* FEEL P2/DRAMA Program Model
* 2001/11/14 11:11
*----------------------------------------------------
      implicit real*8(a-h,o-z)
*------------------------------------------------------------
      integer*4 isumup(*)
      integer*4 enptr(2,*),con(2,*)
      real   *8 x(*),y(*)
      integer*4 ipf(*),ipd(*)
      dimension fem_v(*)
*
      integer*4 enptr_ex(2,*),con_ex(2,*)
      integer*4 ndno(*),peno(*)
      integer*4 ipfex(*),ipdex(*)
      real   *8 x_ex(*),y_ex(*)
*
      real   *8 femex_v(*)
*
      real*8  valmat(*)
      real*8  vfg(*)
      integer indrow(*)
      integer iptrcol(*)
      parameter (NDF = 3)
      parameter (NDP = 3)
*------------------------------------------------------------
* No.1 Numerical integration method[tri4]
       parameter (NPG1 =  6)
*------------------------------------------------------------
      real   *8 ex(NDP),ey(NDP)
      real   *8 efem_v(NDP)
*
      integer*4 ienp(NDF)
      integer*4 iedp(NDF)
      integer*4 ikp (NDF),jkp(NDF)
*------------------------------------------------------------
      common /em1_1/ ea(NDF,NDF),eb(NDF)
*------------------------------------------------------------
      data ienp/1,2,3/
      data iedp/0,0,0/
*------------------------------------------------------------
      call eset1_1_1
*------------------------------------------------------------
      do 100 i=1,nelem
      ipos_from = enptr(1,i  )
      ipos_to   = enptr(1,i+1)-1
      ietype    = enptr(2,i  )
      nodes     = ipos_to-ipos_from+1
*
***** if(ietype .EQ. 1) then
        do 1011 j=1,nodes
          jp=j-1+ipos_from
          if(con(2,jp) .eq. mypeid) then
           ex(j)=x(con(1,jp))
           ey(j)=y(con(1,jp))
           efem_v(j)=fem_v(con(1,jp))
          else
           nd = ndsearch_ex(con(1,jp),
     $                      con(2,jp),ndno,peno,nouter)
           ex(j) = x_ex(nd)
           ey(j) = y_ex(nd)
           efem_v(j)=femex_v(nd)
          endif
 1011   continue
*
        call ecal1_1(ex(1),ey(1),ex(2),ey(2),ex(3),ey(3),efem_v(1),efem_
     $ v(2),efem_v(3))
*-----
* Make ikp(*),jkp(*)
*-------------------------------------
      do 1012 j=1,NDF
       jp   = ienp(j)+ipos_from-1
       ind  = con(1,jp)
       ipe  = con(2,jp)
       if(ipe .EQ. mypeid) then
        ikp(j) = ipd(ind)+iedp(j)
        jkp(j) = ikp(j)  +myeqfrom-1
       else
        nd = ndsearch_ex(ind,ipe,ndno,peno,nouter)
        ikp(j) = 0
        jkp(j) = ipdex(nd)+iedp(j)+isumup(ipe+1)
       endif
1012  continue
            do 1015 j=1,NDF
               ip = ikp(j)
               if(ip .eq. 0) goto 1015
*
               iptf = iptrcol(ip)
               iptt = iptrcol(ip+1)-1
               do 1016 k=1,NDF
                  jp = jkp(k)
                  do 1017 L=iptf,iptt
                     if(indrow(L) .eq. jp) goto 1018
 1017              continue
*--- err
                  write(*,*) '??? ',ip,jp,'(',mypeid,')'
                  call abortexit(mypeid,'1017 indrow')
*--- err
 1018              continue
                  valmat(L) = valmat(L)+ea(j,k)
 1016           continue
 1015        continue
*
            do 1019 j=1,NDF
               if(ikp(j) .eq. 0) goto 1019
               vfg(ikp(j)) = vfg(ikp(j)) + eb(j)
 1019       continue
*****      endif
 100  continue
*---           end of my enptr loop
*------------------------------------------------------------
*------------------------------------------------------------
* External enptr_ex loop
*------------------------------------------------------------
      do 200 i=1,nelem_ex
      ipos_from = enptr_ex(1,i  )
      ipos_to   = enptr_ex(1,i+1)-1
      ietype    = enptr_ex(2,i  )
      nodes     = ipos_to-ipos_from+1
*
***** if(ietype .EQ. 1) then
        do 2011 j=1,nodes
          jp=j-1+ipos_from
          if(con_ex(2,jp) .eq. mypeid) then
           ex(j)=x(con_ex(1,jp))
           ey(j)=y(con_ex(1,jp))
           efem_v(j)=fem_v(con_ex(1,jp))
          else
           nd = ndsearch_ex(con_ex(1,jp),
     $                      con_ex(2,jp),ndno,peno,nouter)
           ex(j) = x_ex(nd)
           ey(j) = y_ex(nd)
           efem_v(j)=femex_v(nd)
          endif
 2011   continue
*
        call ecal1_1(ex(1),ey(1),ex(2),ey(2),ex(3),ey(3),efem_v(1),efem_
     $ v(2),efem_v(3))
*-----
* Make ikp(*),jkp(*)
*-------------------------------------
      do 2012 j=1,NDF
       jp   = ienp(j)+ipos_from-1
       ind  = con_ex(1,jp)
       ipe  = con_ex(2,jp)
       if(ipe .EQ. mypeid) then
        ikp(j) = ipd(ind)+iedp(j)
        jkp(j) = ikp(j)  +myeqfrom-1
       else
        nd = ndsearch_ex(ind,ipe,ndno,peno,nouter)
        ikp(j) = 0
        jkp(j) = ipdex(nd)+iedp(j)+isumup(ipe+1)
       endif
2012  continue
            do 2015 j=1,NDF
               ip = ikp(j)
               if(ip .eq. 0) goto 2015
*
               iptf = iptrcol(ip)
               iptt = iptrcol(ip+1)-1
               do 2016 k=1,NDF
                  jp = jkp(k)
                  do 2017 L=iptf,iptt
                     if(indrow(L) .eq. jp) goto 2018
 2017              continue
*--- err
                  write(*,*) 'in ex',ip,jp,'(',mypeid,')'
                  call abortexit(mypeid,'indrow(ex)')
*--- err
 2018              continue
                  valmat(L) = valmat(L)+ea(j,k)
 2016           continue
 2015        continue
*---
            do 2019 j=1,NDF
               if(ikp(j) .eq. 0) goto 2019
               vfg(ikp(j)) = vfg(ikp(j)) + eb(j)
 2019       continue
*----
*****     endif
 200  continue
*---           end of external enptr loop
*------------------------------------------------------------
      return
      end
