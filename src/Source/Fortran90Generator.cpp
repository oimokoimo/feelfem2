/*
 *  feelfem version 1.0  Copyright(c)  NEC Corporation 1999
 *                       Programmed by Hidehiro  FUJIO
 *
 *  Filename : Fortran90Generator.cpp
 *  Date     : 2000/10/17
 *  Modified : 
 *  
 *  Purpose  : Common solve generator for Fortran90
 *  
 *             copyright();
 *             comment();
 *             timestamp();
 *             
 *            ** Memory allocation code generator **           
 *
 *
 *  feelfem2 (modernized/ported)
 *  Copyright (C) 2025-2026 Hidehiro Fujio and contributors
 *  SPDX-License-Identifier: BSD-3-Clause
 *  Repository: https://github.com/oimokoimo/feelfem2
 *
 *
 *  Notes:
 *
 */

#include <iostream>
#include "feelfuncs.hpp"
#include "Fortran90Generator.hpp"
#include "feeldef.hpp"
#include "Object.hpp"  // for spaceDim


Fortran90Generator::Fortran90Generator()      // constructor
{
  pushFlag = 0;
  srcPtr=srcBUF;

  spaceDim = feelfemobj.GetSpaceDimension();

  return;
}

Fortran90Generator::~Fortran90Generator()=default;    // destructor

void Fortran90Generator::Fortran90GeneratorSetFP(FILE *f )
{
  fp = f;
  return;
}

void Fortran90Generator::writeSource(const char *str)
{
  pushSource(str);
  flushSource();

  return;
}

void Fortran90Generator::pushSourceHAT(const char *str)
{
  while(*str) {
    if(*str == '^') {
      pushSource("**");
    }
    else {
      pushSourceChar(*str);
    }
    str++;
  }
  return;
}

void Fortran90Generator::wrtDEBUGcode(const char *str)
{
  extern int wrtDEBUGcodeFlag;
  if(wrtDEBUGcodeFlag == YES) writeSourceRAW(str);
  return;
}

void Fortran90Generator::writeSourceRAW(const char *str)
{
  fprintf(fp,"%s\n",str);

  return;
}


void Fortran90Generator::pushSource(const char *str)   // str memory cannot be maintained.
{



  int len;
  len = stringLength(str);
  
  if(pushFlag + len > BUFSIZ) {
	  std::cerr << "pushSource string too long.\n";
    abortExit(1);
  }
  
  sprintf(srcPtr,"%s%c",str,'\0');
  srcPtr   = srcPtr+len;
  pushFlag = pushFlag + len;

  return;
}

//modified by Chappy
void Fortran90Generator::pushSourceChar(char c)
{
  // srcBUF の pushFlag 位置に書く。終端NULも含めて溢れチェック。
  if (pushFlag + 1 >= BUFSIZ) {
    std::cerr << "pushSource string too long.\n";
    abortExit(1);
  }

  *srcPtr = c;
  ++srcPtr;
  *srcPtr = '\0';
  ++pushFlag;
}

void Fortran90Generator::pushSourceInt(const int dat)   // str memory cannot be maintained.
{
  char buf[BUFSIZ];
  sprintf(buf,"%d%c",dat,'\0');
  
  pushSource(buf);
  
  return;
}

void Fortran90Generator::pushSourceDbl(const double dat)   // str memory cannot be maintained.
{
  char buf[BUFSIZ];
  sprintf(buf,"%15.11le%c",dat,'\0');

  char *cp = buf;
  while(*cp) {
    if(*cp == 'e') *cp = 'd';
    cp++;
  }
  
  pushSource(buf);
  
  return;
}

void Fortran90Generator::flushSource(const char *str)
{
  pushSource(str);
  flushSource();
  return;
}

void Fortran90Generator::flushSource(void)
{
  int strindex(const char*,const char *);

  srcPtr = srcBUF;

  if( stringLength(srcPtr) == 0) {  // came from com();
    fprintf(fp,"%s\n",srcBUF);
    return;
  }

  if(*srcBUF == '!') {     // if comment do nothing.
    fprintf(fp,"%s\n",srcBUF);
    return;
  }

  // if exists !
  if(strindex(srcBUF,"!")) {
    fprintf(fp,"%s\n",srcBUF);
    return;
  }

  // if exists "'"
  if(strindex(srcBUF,"'")) {
    fprintf(fp,"%s\n",srcBUF);
    return;
  }


  int next;
  char f90buf[F90_MAX_TEXT_LEN];

  while( stringLength( srcPtr ) > F90_TEXT_LENGTH ) {
    
    next = FindNextPOS( srcPtr );
    
    for(int i=0;i<next;i++) {
      f90buf[i] = *(srcPtr+i);
    }
    f90buf[next] = '\0';
    fprintf(fp,"%s &\n",f90buf);

    srcPtr += next;
  }
  
  if(*srcPtr) {
    fprintf(fp,"%s\n",srcPtr);
  }

  // initialize
  srcPtr = srcBUF;
  pushFlag = 0;
  return;
}

void Fortran90Generator::copyright(void) 
{
  writeSource("!--------------------------------------------------------");
  //  writeSource("! Generated by feelfem (C) NEC Corporation 1999-2002");
  writeSource("! Generated by feelfem");
  writeSource("!--------------------------------------------------------");
  return;
}

void Fortran90Generator::timestamp(void) 
{
  char buf[80];
  sprintf(buf,"! %s",getdate());
  writeSource(buf);
  writeSource("!----------------------------------------------------");
  
  return;
}  

void Fortran90Generator::fortImplicit()
{
  writeSource("implicit none");
  com();
  
  return;
}

void Fortran90Generator::comment(void) 
{
  writeSource("!------------------------------------------------------");
  return;
}

void Fortran90Generator::com(void) 
{
  writeSource("");
  return;
}

void Fortran90Generator::COMMENTlong(const char *com)
{
  writeSource("");
  writeSource("!------------------------------------------------------");

  pushSource("! ");
  pushSource(com);
  flushSource();

  writeSource("!------------------------------------------------------");

  
  return;
}

/*---------------------------------------
 * Memory allocation f_alloc function
 *---------------------------------------*/
void Fortran90Generator::mallocF90(const char *varString )

{
  pushSource("allocate(");
  pushSource(varString);
  pushSource(")");

  flushSource();
  return;
}

void Fortran90Generator::mallocF90check(void) 
{
  writeSource("! mallocF90check function");

  return;
}

// private
int Fortran90Generator::FindNextPOS( char *ptr )
{
  int pos;
  int length = stringLength(ptr);
  
  pos = F90_TEXT_FROM;

  while(*(ptr + pos) ) {
    switch(*(ptr+pos) ) {
    case ',':
    case '+':
    case '-':
    case '/':
    case '(':
    case ' ':
      return(pos);

    case '*':
      if(*(ptr+pos+1) != '*' &&
	 *(ptr+pos-1) != '*'    ) {
      	return(pos);
      }
      pos++;
      break;

    default:
      pos++;
    }
  }

  assert(pos <F90_MAX_TEXT_LEN);
  return(pos);
}

      


