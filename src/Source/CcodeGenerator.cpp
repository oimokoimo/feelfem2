/*
 *  feelfem version 1.0  Copyright(c)  NEC Corporation 1999
 *                       Programmed by Hidehiro  FUJIO
 *
 *  Filename : CcodeGenerator.cpp
 *  Date     : 1999/10/26  <- wrong daten
 *  Modified : 2002/03/11
 *  
 *  Purpose  : Common solve generator for C
 *  
 *             copyrightC();
 *             timestampC();
 *             commentC();
 *             
 *
 *  feelfem2 (modernized/ported)
 *  Copyright (C) 2025-2026 Hidehiro Fujio and contributors
 *  SPDX-License-Identifier: BSD-3-Clause
 *  Repository: https://github.com/oimokoimo/feelfem2
 *
 *
 *  Notes:
 *  
 */


#include "feelfuncs.hpp"
#include "CcodeGenerator.hpp"
#include "feeldef.hpp"


CcodeGenerator::CcodeGenerator()
{
  return;        // do nothing now
}

CcodeGenerator::~CcodeGenerator() = default;

void CcodeGenerator::CcodeGeneratorSetFP(FILE *f)
{
  fp = f;
  return;
}

void CcodeGenerator::Csrc(const char *str)
{
  pushSource( str );
  flushSource();
  return;
}


void CcodeGenerator::copyright(void) 
{
  writeSource("/*--------------------------------------------------------*");
  writeSource(" * Generated by feelfem2 2000-2026                        *");
  writeSource(" *--------------------------------------------------------*/");
  return;
}

void CcodeGenerator::timestamp(void) {
  char buf[80];

  Csrc("/*------------------------");
  sprintf(buf," %s",getdate());
  Csrc(buf);
  Csrc(" *------------------------/");
  return;
}

void CcodeGenerator::comment(void) {
  Csrc("/**/");
  return;
}

void CcodeGenerator::com(void)
{
  Csrc("");
  return;
}

void CcodeGenerator::COMMENTlong(const char *com)
{
  writeSource("");
  writeSource("!------------------------------------------------------");

  pushSource("! ");
  pushSource(com);
  flushSource();

  writeSource("!------------------------------------------------------");

  return;
}

void CcodeGenerator::writeSource(const char *str)
{
  pushSource(str);
  flushSource();

  return;
}

void CcodeGenerator::wrtDEBUGcode(const char *str)
{
  extern int wrtDEBUGcodeFlag;
  if(wrtDEBUGcodeFlag == YES) writeSourceRAW(str);
  return;
}

void CcodeGenerator::writeSourceRAW(const char *str)
{
  fprintf(fp,"%s",str);
  return;
}

void CcodeGenerator::pushSource(const char *str)   // str memory cannot be maintained.
{
  int len;
  len = stringLength(str);

  if(pushFlag + len > BUFSIZ) {
    std::cerr << "pushSource string too long.\n";
    abortExit(1);
  }
  
  sprintf(srcPtr,"%s%c",str,'\0');
  srcPtr   = srcPtr+len;
  pushFlag = pushFlag + len;
  
  return;
}

void CcodeGenerator::pushSourceChar(char c)
{
  if(pushFlag + 1 > BUFSIZ) {
    std::cerr << "pushSource string too long.\n";
    abortExit(1);
  }
  
  sprintf(srcPtr,"%s%c",srcPtr,'\0');
  *srcPtr     = c;
  *(srcPtr+1) = '\0';
  srcPtr   = srcPtr++;
  pushFlag = pushFlag + 1;
  
  return;
}

void CcodeGenerator::pushSourceInt(const int dat)   // str memory cannot be maintained.
{
  char buf[BUFSIZ];
  sprintf(buf,"%d%c",dat,'\0');
  
  pushSource(buf);
  
  return;
}

void CcodeGenerator::pushSourceDbl(const double dat)   // str memory cannot be maintained.
{
  char buf[BUFSIZ];
  sprintf(buf,"%15.11le%c",dat,'\0');

  char *cp = buf;
  while(*cp) {
    if(*cp == 'e') *cp = 'd';
    cp++;
  }
  pushSource(buf);
  
  return;
}

void CcodeGenerator::flushSource(const char *str)
{
  pushSource(str);
  flushSource();
  return;
}

void CcodeGenerator::flushSource(void)
{
  int strindex(const char*,const char *);

  srcPtr = srcBUF;

  if( stringLength(srcPtr) == 0) {  // came from com();
    fprintf(fp,"%s\n",srcBUF);
    return;
  }

  // if exists "'"
  //  if(strindex(srcBUF,"'")) {
  //    fprintf(fp,"%s\n",srcBUF);
  //    return;
  //  }


  int next;
  char cbuf[C_MAX_TEXT_LEN];

  while( stringLength( srcPtr ) > C_TEXT_LENGTH ) {
    
    next = FindNextPOS( srcPtr );
    
    for(int i=0;i<next;i++) {
      cbuf[i] = *(srcPtr+i);
    }
    cbuf[next] = '\0';
    fprintf(fp,"%s &\n",cbuf);

    srcPtr += next;
  }
  
  if(*srcPtr) {
    fprintf(fp,"%s\n",srcPtr);
  }

  // initialize
  srcPtr = srcBUF;
  pushFlag = 0;
  return;
}

// private
int CcodeGenerator::FindNextPOS( char *ptr )
{
  int pos;
  int length = stringLength(ptr);
  
  pos = C_TEXT_FROM;

  while(*(ptr + pos) ) {
    switch(*(ptr+pos) ) {
    case ',':
    case '+':
    case '-':
    case '/':
    case '(':
    case ' ':
      return(pos);

    case '*':
      if(*(ptr+pos+1) != '*' &&
	 *(ptr+pos-1) != '*'    ) {
      	return(pos);
      }
      pos++;
      break;

    default:
      pos++;
    }
  }

  assert(pos <C_MAX_TEXT_LEN);
  return(pos);
}
