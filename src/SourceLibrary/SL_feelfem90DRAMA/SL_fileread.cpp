/*
 *  feelfem v1.0 NEC Corporation (C) 1999,2000,2001
 *                   Programmed  by  Hidehiro FUJIO
 *
 *  Filename : SL_fileread.cpp
 *  Date     : 2003/03/02 20:50
 *  Purpose  : Library module generator
 *
 *
 *  feelfem2 (modernized/ported)
 *  Copyright (C) 2025-2026 Hidehiro Fujio and contributors
 *  SPDX-License-Identifier: BSD-3-Clause
 *  Repository: https://github.com/oimokoimo/feelfem2
 *
 *
 *  Notes:
 *
 */
#include "SL_feelfem90DRAMA.hpp"

static int come_yet_fileread = 0;


void SL_feelfem90DRAMA::SL_fileread(int makeFlag)
{
  const char *sourceName;

  if(come_yet_fileread == 1)  return;
  else                  come_yet_fileread = 1;

  sourceName = GetSourceName("fileread");
  OpenSource(sourceName,makeFlag);

  // ORIGINAL SOURCE STARTS-----------------


  writeSource("module fileread");
  com();
  writeSource("! For aistpcp90 ProgramModel  2002/07/02");
  com();
  writeSource("! METIS epart data read");
  writeSource("! readmetis");
  com();
  com();
  writeSource("integer,parameter,private   :: ioin  = 10            ! Read open unit number");
  com();
  writeSource("contains");
  com();
  writeSource("subroutine readmetis(myrank,nprocs,nelem_g,iedom)");
  writeSource("use numeric");
  writeSource("implicit none");
  com();
  writeSource("integer,intent(in)           :: myrank");
  writeSource("integer,intent(in)           :: nprocs");
  writeSource("integer,intent(in)           :: nelem_g      ! total number of element");
  writeSource("integer,dimension(:),pointer :: iedom        ! metis elementwise partition data");
  com();
  writeSource("integer                      :: nelem        ! read element data");
  writeSource("character(len=50)            :: filename");
  com();
  writeSource("integer                      :: i");
  writeSource("!------------------------------------------------------------------");
  writeSource("  if(nprocs < 10) then");
  writeSource("     write(filename,7801) nprocs");
  writeSource("7801 format('feel.metis.epart.',i1)");
  writeSource("  else if(nprocs < 100) then");
  writeSource("     write(filename,7802) nprocs");
  writeSource("7802 format('feel.metis.epart.',i2)");
  writeSource("  else if(nprocs < 1000) then");
  writeSource("     write(filename,7803) nprocs");
  writeSource("7803 format('feel.metis.epart.',i3)");
  writeSource("  else");
  writeSource("     write(*,*) 'too many partitions.'");
  writeSource("     stop");
  writeSource("  endif");
  com();
  com();
  writeSource("  open(file=filename,unit=ioin,status='old',err=9999)");
  writeSource("  do i=1,nelem_g");
  writeSource("     read(ioin,*) iedom(i)");
  writeSource("  end do");
  com();
  writeSource("  close(ioin)");
  writeSource("  return");
  com();
  writeSource("9999 continue");
  com();
  writeSource("  write(*,*) '***************************************************'");
  writeSource("  write(*,9998) nprocs");
  writeSource("9998 format( '*  Number of Processors =',i4,'                      *')");
  writeSource("  write(*,*) '*  Cannot open METIS partition file.              *'");
  writeSource("  write(*,*) '*                                                 *'");
  writeSource("  write(*,*) '*                                                 *'");
  writeSource("  write(*,*) '*  Appropriate METIS partition file must be made. *'");
  writeSource("  write(*,*) '*                                                 *'");
  writeSource("  write(*,*) '***************************************************'");
  com();
  writeSource("  stop 'reading metis partition data(readmetis routine)'");
  com();
  com();
  writeSource("end subroutine readmetis");
  com();
  writeSource("subroutine ctrlinp(meshDat, solveLst,ierror)");
  writeSource("use femDataType");
  writeSource("use numeric");
  writeSource("implicit none");
  com();
  writeSource("type(meshInformation)        :: meshDat");
  writeSource("type(solveList)              :: solveLst");
  writeSource("integer                      :: ierror");
  com();
  com();
  writeSource("!-------------------------------------------");
  writeSource("! Auto variables");
  writeSource("!-------------------------------------------");
  writeSource("integer                        :: i,j,k");
  com();
  writeSource("character(len = 4)             :: word");
  com();
  writeSource("! Input buffer pointer");
  com();
  writeSource("integer,dimension(:),pointer   :: inpbuf");
  com();
  writeSource("! for Mesh information");
  writeSource("integer                        :: nredat,nbedat");
  com();
  writeSource("! for Solve information");
  writeSource("integer                        :: solves");
  writeSource("type(solveInformation),pointer :: solveInfoPtr");
  writeSource("type(solveInformation), &");
  writeSource("    dimension(:),pointer       :: solveDataList");
  com();
  writeSource("integer                        :: solveNo");
  writeSource("integer                        :: solveEdatNo");
  writeSource("integer                        :: dconds");
  writeSource("integer                        :: nconds");
  com();
  writeSource("integer                        :: condNo");
  writeSource("integer                        :: condFlag");
  writeSource("integer                        :: datasets");
  com();
  writeSource("type(boundaryDataSet),dimension(:),pointer :: dlst");
  writeSource("type(boundaryDataSet),dimension(:),pointer :: nlst");
  com();
  writeSource("type(boundaryDataSet),pointer  :: bdsetPtr");
  writeSource("!-------------------------------");
  writeSource("ierror = Non");
  com();
  writeSource("open(ioin,file='solv_dat',status='old',action='read')");
  com();
  writeSource("!----------------");
  writeSource("! PROB Keyword");
  writeSource("!----------------");
  writeSource("read(ioin,'(a4)') word");
  writeSource("if(word .ne. 'PROB') then");
  writeSource("  ierror = Oui");
  writeSource("  close(ioin)");
  writeSource("  write(*,*) 'solve_dat DATA ERR(KEYWORD PROB NOT FOUND)'");
  writeSource("  return");
  writeSource("endif");
  com();
  writeSource("!----------------");
  writeSource("! MEDT  Main edat");
  writeSource("!----------------");
  writeSource("read(ioin,'(a4)') word");
  writeSource("if(word .ne. 'MEDT') then");
  writeSource("  ierror = Oui");
  writeSource("  close(ioin)");
  writeSource("  write(*,*) 'solve_dat DATA ERR(KEYWORD MEDT NOT FOUND)'");
  writeSource("  return");
  writeSource("endif");
  com();
  com();
  writeSource("read(ioin,'(i8)')    meshDat\%medtNo     ! medtNo     is main EDAT for GiD");
  writeSource("meshDat\%mainEdatNo = meshDat\%medtNo     ! mainEdatNo is used in let sentences");
  com();
  writeSource("!-----------------");
  writeSource("! REDT Region edat");
  writeSource("!-----------------");
  writeSource("read(ioin,'(a4)') word");
  writeSource("if(word .ne. 'REDT') then");
  writeSource("  ierror = Oui");
  writeSource("  close(ioin)");
  writeSource("  write(*,*) 'solve_dat DATA ERR(KEYWORD REDT NOT FOUND)'");
  writeSource("  return");
  writeSource("endif");
  com();
  writeSource("read(ioin,'(i8)') nredat");
  writeSource("allocate(inpbuf(nredat))");
  writeSource("meshDat\%regionEdats =  nredat");
  writeSource("meshDat\%redatlist   => inpbuf");
  com();
  writeSource("read(ioin,'((8i8))') (inpbuf(i),i=1,nredat)");
  com();
  writeSource("!-------------------");
  writeSource("! BEDT Boundary edat");
  writeSource("!-------------------");
  writeSource("read(ioin,'(a4)') word");
  writeSource("if(word .ne. 'BEDT') then");
  writeSource("  ierror = Oui");
  writeSource("  close(ioin)");
  writeSource("  write(*,*) 'solve_dat DATA ERR(KEYWORD BEDT NOT FOUND)'");
  writeSource("  return");
  writeSource("endif");
  com();
  writeSource("read(ioin,'(i8)') nbedat");
  writeSource("meshDat\%boundaryEdats =  nbedat");
  com();
  writeSource("if(nbedat .ne. 0) then");
  writeSource("  allocate(inpbuf(nbedat))");
  writeSource("  meshDat\%bedatlist     => inpbuf");
  writeSource("  read(ioin,'((8i8))') (inpbuf(i),i=1,nbedat)");
  writeSource("else");
  writeSource("  nullify(meshDat\%bedatlist)");
  writeSource("endif");
  com();
  writeSource("!-------------------------");
  writeSource("! Solve information");
  writeSource("!-------------------------");
  writeSource("read(ioin,'(a4)') word");
  writeSource("if(word .ne. 'SLVS') then");
  writeSource("  ierror = Oui");
  writeSource("  close(ioin)");
  writeSource("  write(*,*) 'solve_dat DATA ERR(KEYWORD SLVS NOT FOUND)'");
  writeSource("  return");
  writeSource("endif");
  com();
  writeSource("read(ioin,'(i8)') solves");
  writeSource("solveLst\%solves = solves");
  com();
  writeSource("if(solves == 0) then");
  writeSource("   close(ioin)");
  writeSource("   return");
  writeSource("end if");
  com();
  writeSource("!----------------------");
  writeSource("! Solve DATA repetition");
  writeSource("!----------------------");
  com();
  writeSource("allocate(solveDataList(solves))");
  writeSource("solveLst\%solveDataList => solveDataList");
  com();
  writeSource("do i=1,solves");
  com();
  com();
  writeSource("   ! SOLV");
  writeSource("   read(ioin,'(a4)') word");
  writeSource("   if(word .ne. 'SOLV') then");
  writeSource("      ierror = Oui");
  writeSource("      close(ioin)");
  writeSource("      write(*,*) 'solve_dat DATA ERR. KEYWORD SOLV NOT FOUND for No.',i");
  writeSource("      stop");
  writeSource("   endif");
  com();
  writeSource("   ! solveNo");
  writeSource("   read(ioin,'(i8)') solveNo");
  writeSource("   read(ioin,'(i8)') solveEdatNo");
  writeSource("   read(ioin,'(i8)') dconds");
  writeSource("   read(ioin,'(i8)') nconds");
  com();
  writeSource("   solveInfoPtr => solveDataList(i)   ! memory is allocated");
  com();
  writeSource("   solveInfoPtr\%solveNo = solveNo");
  writeSource("   solveInfoPtr\%edatno  = solveEdatNo");
  writeSource("   solveInfoPtr\%dconds  = dconds");
  writeSource("   solveInfoPtr\%nconds  = nconds");
  com();
  writeSource("   ! Dirichlet conds");
  writeSource("   if(dconds > 0) then");
  com();
  writeSource("      allocate(dlst(dconds))");
  writeSource("      solveInfoPtr\%dlst => dlst");
  com();
  writeSource("      do j=1,dconds");
  com();
  writeSource("         ! j-th DCND");
  writeSource("         read(ioin,'(a4)') word");
  writeSource("         if(word .ne. 'DCND') then");
  writeSource("            write(*,*) 'Data error DCND, solve No.',solveNo,' dcond No.',j");
  writeSource("            stop");
  writeSource("         endif");
  com();
  writeSource("         bdsetPtr => dlst(j)");
  com();
  writeSource("         read(ioin,'(2i8)') condNo,datasets");
  com();
  writeSource("         allocate(inpbuf(datasets))");
  writeSource("         bdsetPtr\%solveNo   =  solveNo");
  writeSource("         bdsetPtr\%condType  =  1            ! dcond = 1  ncond = 2");
  writeSource("         bdsetPtr\%condNo    =  condNo");
  writeSource("         bdsetPtr\%nofsets   =  datasets");
  writeSource("         bdsetPtr\%datlist   => inpbuf");
  com();
  writeSource("         read(ioin,'((8i8))') (inpbuf(k),k=1,datasets)");
  com();
  writeSource("      end do  ! end of dconds loop");
  com();
  writeSource("   end if  ! end of if(dcond >0)");
  com();
  com();
  writeSource("   ! Neumann conds");
  writeSource("   if(nconds > 0) then");
  com();
  writeSource("      allocate(nlst(nconds))");
  writeSource("      solveInfoPtr\%nlst => nlst");
  com();
  writeSource("      do j=1,nconds");
  com();
  writeSource("         ! j-th NCND");
  writeSource("         read(ioin,'(a4)') word");
  writeSource("         if(word .ne. 'NCND') then");
  writeSource("            write(*,*) 'Data error NCND, solve No.',solveNo,' ncond No.',j");
  writeSource("            stop");
  writeSource("         endif");
  com();
  writeSource("         bdsetPtr => nlst(j)");
  com();
  writeSource("         read(ioin,'(2i8)') condNo,datasets");
  com();
  writeSource("         allocate(inpbuf(datasets))");
  writeSource("         bdsetPtr\%solveNo   =  solveNo");
  writeSource("         bdsetPtr\%condType  =  2            ! dcond = 1  ncond = 2");
  writeSource("         bdsetPtr\%condNo    =  condNo");
  writeSource("         bdsetPtr\%nofsets   =  datasets");
  writeSource("         bdsetPtr\%datlist   => inpbuf");
  com();
  writeSource("         read(ioin,'((8i8))') (inpbuf(k),k=1,datasets)");
  com();
  writeSource("      end do  ! end of nconds loop");
  com();
  writeSource("   end if  ! end of if(ncond >0)");
  com();
  writeSource("end do");
  com();
  writeSource("close(ioin)");
  writeSource("return");
  com();
  writeSource("end subroutine ctrlinp");
  com();
  com();
  writeSource("subroutine datinp(ndim,npmax,nelem_g,nedat,nnset,nnum,nip,           &");
  writeSource("                  mode_ex,mode_output,nvars_fem,nvars_ewise,         &");
  writeSource("                  x,y,z,                                             &");
  writeSource("                  firstEdatPtr,firstNsetPtr,numData,ipData ,matData, &");
  writeSource("                  ierror  )");
  com();
  writeSource("use numeric");
  writeSource("use femDataType");
  writeSource("implicit none");
  com();
  writeSource("! feel_dat fundamental parameters");
  com();
  writeSource("integer(kind=INT4 )            :: ndim             ! space dimension");
  writeSource("integer(kind=INT4 )            :: npmax            ! nodes(global/local)");
  writeSource("integer(kind=INT4 )            :: nelem_g          ! number of region element");
  writeSource("integer(kind=INT4 )            :: nedat");
  writeSource("integer(kind=INT4 )            :: nnset");
  writeSource("integer(kind=INT4 )            :: nnum");
  writeSource("integer(kind=INT4 )            :: nip");
  com();
  writeSource("integer(kind=INT4 )            :: mode_ex");
  writeSource("integer(kind=INT4 )            :: mode_output");
  writeSource("integer(kind=INT4 )            :: nvars_fem,nvars_ewise");
  com();
  writeSource("real   (kind=REAL8),dimension(:),pointer :: x,y,z");
  com();
  writeSource("type(edatList),pointer         :: firstEdatPtr");
  writeSource("type(nsetList),pointer         :: firstNsetPtr");
  writeSource("type(numdat)  ,pointer         :: numData");
  writeSource("type(ipdat)   ,pointer         :: ipData");
  writeSource("type(matdat)  ,pointer         :: matData");
  com();
  writeSource("integer(kind=INT4 )            :: ierror");
  com();
  writeSource("!---------------------------------------------------------------");
  writeSource("! Auto variable");
  writeSource("!---------------------------------------------------------------");
  com();
  writeSource("integer                        :: i,j");
  com();
  writeSource("! --------");
  writeSource("! feel_dat");
  writeSource("! --------");
  writeSource("character(len = 4 )            :: word                       ! feel_dat keyword");
  writeSource("integer                        :: nodeFlag,edatFlag,nsetFlag");
  com();
  writeSource("! ------------");
  writeSource("! EDAT/NSET/IP");
  writeSource("! ------------");
  writeSource("integer                        :: no");
  writeSource("integer                        :: np");
  com();
  writeSource("! ----");
  writeSource("! EDAT");
  writeSource("! ----");
  writeSource("type(edat), pointer            :: edatData");
  writeSource("type(edatList),pointer         :: currentEdatPtr,edatPtr");
  com();
  writeSource("integer(kind=INT4 )            :: netype");
  writeSource("integer,dimension(:,:),pointer :: ielem             ! for reading");
  writeSource("integer,dimension(:)  ,pointer :: matno             ! for reading");
  com();
  writeSource("integer                        :: nelem");
  com();
  writeSource("! ----");
  writeSource("! NSET");
  writeSource("! ----");
  writeSource("type(nset), pointer            :: nsetData");
  writeSource("type(nsetList),pointer         :: currentNsetPtr,nsetPtr");
  com();
  writeSource("integer,dimension(:,:),pointer :: inset");
  writeSource("integer                        :: nodes");
  com();
  writeSource("! ----");
  writeSource("! NODE");
  writeSource("! ----");
  writeSource("integer                                  :: inp");
  writeSource("real   (kind=REAL8)                      :: xx,yy,zz          ! for reading");
  com();
  com();
  writeSource("! ----");
  writeSource("! NUM");
  writeSource("! ----");
  writeSource("real(kind=REAL8) ,dimension(:),pointer   :: ndat");
  com();
  com();
  writeSource("! ----");
  writeSource("! IP");
  writeSource("! ----");
  writeSource("integer,dimension(:),pointer             :: ipno");
  com();
  writeSource("! ----");
  writeSource("! REGN");
  writeSource("! ----");
  writeSource("integer                                  :: regions");
  writeSource("integer,dimension(:),pointer             :: regmat");
  com();
  com();
  writeSource("!-----------------------");
  writeSource("! Read feel_dat datafile");
  writeSource("!-----------------------");
  writeSource("  ierror = Non");
  com();
  writeSource("  open(ioin,file='feel_dat',status ='old',action='read')");
  com();
  writeSource("  read(ioin,'(a4)') word");
  writeSource("  if(word .ne. 'FEEL') then");
  writeSource("    write(*,*) 'First keyword is not FEEL'");
  writeSource("    ierror = Oui");
  writeSource("    close(ioin)");
  writeSource("    return");
  writeSource("  endif");
  com();
  writeSource("  read(ioin,'(6i8)') ndim,npmax,nedat,nnset,nnum,nip");
  writeSource("  read(ioin,'(2i8)') mode_ex,mode_output");
  writeSource("  read(ioin,'(2i8)') nvars_fem,nvars_ewise");
  com();
  writeSource("  nodeFlag = notYet");
  writeSource("  edatFlag = notYet");
  writeSource("  nsetFlag = notYet");
  com();
  writeSource("  nullify(firstNsetPtr,firstEdatPtr,ipData)");
  com();
  com();
  com();
  writeSource("1000 read(ioin,'(a4)') word");
  com();
  writeSource("  select case(word)");
  writeSource("   case('END ')");
  writeSource("     goto 1999");
  com();
  writeSource("   case('NODE')");
  writeSource("     if(nodeFlag == already) then");
  writeSource("       write(*,*)'NODE section duplicate'");
  writeSource("       ierror = Oui");
  writeSource("       close(ioin)");
  writeSource("       return");
  writeSource("     endif");
  writeSource("     nodeFlag = already");
  com();
  writeSource("     if( ndim == 1 ) then");
  writeSource("        allocate(x(npmax))");
  writeSource("1001    read(ioin,'(i8,E12.5)') inp,xx");
  writeSource("        if(inp .ne. 0) then");
  writeSource("           x(inp) = xx; goto 1001");
  writeSource("        endif");
  writeSource("     endif");
  com();
  writeSource("     if( ndim == 2 ) then");
  writeSource("        allocate(x(npmax),y(npmax))");
  writeSource("1002    read(ioin,'(i8,E12.5,E12.5)') inp,xx,yy");
  writeSource("        if(inp .ne. 0) then");
  writeSource("           x(inp)=xx; y(inp)=yy; goto 1002");
  writeSource("        endif");
  writeSource("     endif");
  com();
  writeSource("     if( ndim == 3 ) then");
  writeSource("        allocate(x(npmax),y(npmax),z(npmax))");
  writeSource("1003    read(ioin,'(i8,E12.5,E12.5,E12.5)') inp,xx,yy,zz");
  writeSource("        if(inp .ne. 0) then");
  writeSource("           x(inp)=xx; y(inp)=yy; z(inp)=zz; goto 1003");
  writeSource("        endif");
  writeSource("     endif");
  com();
  writeSource("   case('EDAT')");
  writeSource("     read(ioin,'(4i8)') no,nelem,np,netype");
  com();
  writeSource("     if(no .eq. 1) then");
  writeSource("       nelem_g = nelem         ! feel_dat limitation");
  writeSource("     endif");
  writeSource("     if(netype == 0) then");
  writeSource("        write(*,*) 'Warning: netype(element type) for EDAT ',no,' is 0'");
  writeSource("     end if");
  com();
  writeSource("     allocate(edatData,edatPtr,ielem(np,nelem),matno(nelem))");
  writeSource("     edatData\%ielem => ielem");
  writeSource("     edatData\%matno => matno");
  writeSource("     edatData\%no    =  no");
  writeSource("     edatData\%nelem =  nelem");
  writeSource("     edatData\%np    =  np");
  writeSource("     edatData\%netype=  netype");
  com();
  writeSource("     edatPtr\%no       =  no             ! List pointer has also no. data");
  writeSource("     edatPtr\%edatData => edatData");
  writeSource("     nullify(edatPtr\%next)");
  com();
  com();
  writeSource("     if(edatFlag == notYet) then");
  writeSource("       firstEdatPtr=>edatPtr");
  writeSource("       currentEdatPtr=>edatPtr");
  writeSource("       edatFlag  = already");
  writeSource("     else");
  writeSource("       currentEdatPtr\%next =>edatPtr");
  writeSource("       currentEdatPtr=>edatPtr");
  writeSource("     endif");
  com();
  com();
  writeSource("     do i=1,nelem");
  writeSource("      read(ioin,*) (ielem(j,i),j=1,np),matno(i)");
  writeSource("     end do");
  com();
  com();
  com();
  writeSource("   case('NSET')");
  writeSource("     read(ioin,'(3i8)') no,nodes,np");
  com();
  writeSource("     allocate(nsetData,nsetPtr,inset(np,nodes))");
  writeSource("     nsetData\%inset   =>inset");
  writeSource("     nsetData\%no      = no");
  writeSource("     nsetData\%np      = np");
  writeSource("     nsetData\%nodes   = nodes");
  com();
  writeSource("     nsetPtr\%no       = no");
  writeSource("     nsetPtr\%nsetData => nsetData");
  writeSource("     nullify(nsetPtr\%next)");
  com();
  writeSource("     if(nsetFlag == notYet) then");
  writeSource("       firstNsetPtr   => nsetPtr");
  writeSource("       currentNsetPtr => nsetPtr");
  writeSource("       nsetFlag       =  already");
  writeSource("     else");
  writeSource("       currentNsetPtr\%next => nsetPtr");
  writeSource("       currentNsetPtr      => nsetPtr");
  writeSource("     endif");
  com();
  writeSource("     do i=1,nodes");
  writeSource("       read(ioin,*) (inset(j,i),j=1,np)");
  writeSource("     end do");
  com();
  com();
  com();
  writeSource("   case('NUM ')");
  writeSource("     allocate(numData,ndat(nnum))");
  com();
  writeSource("     numData\%dat     => ndat");
  writeSource("     numData\%numbers =  nnum");
  com();
  writeSource("     read(ioin,'((E15.5))') (ndat(i),i=1,nnum)");
  com();
  writeSource("  case('IP  ')");
  writeSource("     allocate(ipData,ipno(nip))");
  com();
  writeSource("     ipData\%ipno     => ipno");
  writeSource("     ipData\%nodes    =  nip");
  com();
  writeSource("     read(ioin,'((8i8))') (ipno(i),i=1,nip)");
  com();
  writeSource("  case('REGN')");
  com();
  writeSource("     read(ioin,'(i8)') regions");
  writeSource("     allocate(matData,regmat(regions))");
  com();
  writeSource("     matData\%regions =  regions");
  writeSource("     matData\%regmat  => regmat");
  com();
  writeSource("     read(ioin,'((i8))') (regmat(i),i=1,regions)");
  com();
  com();
  writeSource("  end select");
  com();
  writeSource("  goto 1000");
  com();
  com();
  writeSource("1999 close(ioin)");
  com();
  writeSource("end subroutine datinp");
  com();
  writeSource("subroutine read_metis(nprocs,nelem_g,metis,ierror)");
  writeSource("!---");
  writeSource("use numeric");
  writeSource("implicit none");
  com();
  writeSource("integer                    :: nprocs");
  writeSource("integer                    :: nelem_g");
  writeSource("integer,dimension(nelem_g) :: metis");
  writeSource("integer                    :: ierror");
  com();
  writeSource("!auto variable");
  writeSource("integer                    :: i");
  writeSource("integer                    :: inp");
  writeSource("integer                    :: nprocs_check");
  writeSource("integer                    :: metis2feel(nelem_g)");
  writeSource("!---");
  com();
  writeSource("  ierror = Non");
  com();
  writeSource("  open(ioin,file='metis.bamg',status='old',action='read')");
  writeSource("  do i=1,nelem_g");
  writeSource("    read(ioin,*) metis2feel(i)");
  writeSource("  end do");
  writeSource("  close(ioin)");
  com();
  writeSource("  open(ioin,file='metis.feel',status='old',action='read')");
  writeSource("  do i=1,nelem_g");
  writeSource("    read(ioin,*) inp");
  writeSource("    metis(inp) = metis2feel(i)");
  writeSource("  end do");
  writeSource("  close(ioin)");
  com();
  writeSource("  nprocs_check = -1");
  writeSource("  do i=1,nelem_g");
  writeSource("    if(nprocs_check < metis(i)) then");
  writeSource("      nprocs_check = metis(i)");
  writeSource("    end if");
  writeSource("  end do");
  writeSource("  nprocs_check = nprocs_check + 1");
  com();
  writeSource("  if(nprocs .ne. nprocs_check) then");
  writeSource("    write(*,*) 'Number of processor is mismatch'");
  writeSource("    ierror = Oui");
  writeSource("    return");
  writeSource("  endif");
  com();
  writeSource("end subroutine read_metis");
  com();
  writeSource("end module fileread");

  // ORIGINAL SOURCE END-------------------

  CloseSource();

  return;
}
