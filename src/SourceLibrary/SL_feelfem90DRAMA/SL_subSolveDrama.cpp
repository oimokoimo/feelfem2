/*
 *  feelfem v1.0 NEC Corporation (C) 1999,2000,2001
 *                   Programmed  by  Hidehiro FUJIO
 *
 *  Filename : SL_subSolveDrama.cpp
 *  Date     : 2003/03/02 20:50
 *  Purpose  : Library module generator
 *
 *
 *  feelfem2 (modernized/ported)
 *  Copyright (C) 2025-2026 Hidehiro Fujio and contributors
 *  SPDX-License-Identifier: BSD-3-Clause
 *  Repository: https://github.com/oimokoimo/feelfem2
 *
 *
 *  Notes:
 *
 */
#include "SL_feelfem90DRAMA.hpp"

static int come_yet_subSolveDrama = 0;


void SL_feelfem90DRAMA::SL_subSolveDrama(int makeFlag)
{
  const char *sourceName;

  if(come_yet_subSolveDrama == 1)  return;
  else                  come_yet_subSolveDrama = 1;

  sourceName = GetSourceName("subSolveDrama");
  OpenSource(sourceName,makeFlag);

  // ORIGINAL SOURCE STARTS-----------------


  writeSource("module subSolveDrama");
  writeSource("!---------------------------------------------------------");
  writeSource("! Problem independent subsidiary routines for solve routine");
  com();
  writeSource("! feelfemf90/drama model");
  com();
  writeSource("! subroutine makeipfdrama : Make freedom array for each node");
  writeSource("! subroutine makeipddrama : (Independent of DRAMA)");
  writeSource("! subroutine mksendlst    :");
  writeSource("! subroutine pnc_connect90: Calculate maximul number of connecting nodes");
  com();
  writeSource("! function   ndsearch_ex  : outer node search :(if not found, abort)");
  writeSource("! function   ndsearch_ex2 : return NodeError(-1) if not found");
  writeSource("! function   dramafemval  : search and return fem_ex value");
  writeSource("!---------------------------------------------------------");
  writeSource("contains");
  com();
  writeSource("subroutine makeipfdrama(mypeid,nenfre,maxElementFreedom,neg, &");
  writeSource("                        enptr,con,nelem,npmax,ipf)");
  writeSource("!---------------");
  writeSource("! calculate ipf(*) array with drama double index enptr/con and nenfre");
  writeSource("!---------------");
  writeSource("use abortmodule");
  writeSource("use numeric");
  writeSource("implicit none");
  writeSource("integer                                  :: mypeid");
  writeSource("integer                                  :: maxElementFreedom,neg");
  writeSource("integer                                  :: nelem,npmax");
  com();
  writeSource("integer,dimension(maxElementFreedom,neg) :: nenfre");
  writeSource("integer,dimension(2,nelem)               :: enptr");
  writeSource("integer                                  :: con(2,*)");
  writeSource("integer,dimension(npmax)                 :: ipf");
  com();
  writeSource("! auto variables");
  com();
  writeSource("integer                    :: i,j");
  writeSource("integer                    :: ipos_from,ipos_to");
  writeSource("integer                    :: elementType");
  writeSource("integer                    :: iptr");
  com();
  writeSource("!-------------------------------------------------------------");
  com();
  writeSource("!  initialize ipf = number of freedom at each node");
  com();
  writeSource("do i=1,npmax");
  writeSource("  ipf(i) = 0");
  writeSource("end do");
  com();
  com();
  com();
  writeSource("do i=1,nelem");
  writeSource("   ipos_from = enptr(1,i)");
  writeSource("   ipos_to   = enptr(1,i+1)-1");
  com();
  writeSource("   elementType = enptr(2,i)");
  com();
  writeSource("   if(elementType .EQ. Nur_One_Etype) then");
  writeSource("     do j=ipos_from,ipos_to");
  writeSource("       iptr = j - ipos_from + 1");
  writeSource("       if(con(2,j) .eq. mypeid) then");
  writeSource("         ipf(con(1,j)) = nenfre(iptr,0001)   ! 0001 means nur one etype");
  writeSource("       endif");
  writeSource("     end do");
  writeSource("   else");
  com();
  writeSource("     write(*,*) 'elementType =',elementType,' i=',i");
  writeSource("     write(*,*) 'Not allowed element type in enptr(2,*) feel_dat limitation '");
  writeSource("     call abortexit(mypeid)");
  writeSource("   endif");
  writeSource("end do");
  com();
  writeSource("end subroutine makeipfdrama");
  com();
  writeSource("subroutine makeipddrama(ipf,ipd,npmax,neq)");
  writeSource("use abortmodule");
  writeSource("implicit none");
  com();
  writeSource("integer                    :: npmax");
  writeSource("integer                    :: neq");
  writeSource("integer ,dimension(npmax)  :: ipf,ipd");
  com();
  writeSource("! auto variables");
  com();
  writeSource("integer                    :: i");
  writeSource("integer                    :: istart");
  writeSource("integer                    :: nowfree");
  com();
  writeSource("!-----------------------------------------------------");
  com();
  writeSource("! initialization");
  writeSource("neq = 0");
  writeSource("do i=1,npmax");
  writeSource("   ipd(i) = 0");
  writeSource("end do");
  com();
  com();
  writeSource("! find first freedom");
  com();
  writeSource("istart = 0");
  writeSource("do i=1,npmax");
  writeSource("  if(ipf(i) .ne. 0) then");
  writeSource("    istart = i");
  writeSource("    exit");
  writeSource("  endif");
  writeSource("end do");
  com();
  writeSource("! cannot find the first degree of freedom");
  writeSource("if(istart .eq. 0) then");
  writeSource("  write(*,*) 'Cannot find first degree of freedom'");
  writeSource("  call abortexit(-999)");
  writeSource("endif");
  com();
  com();
  writeSource("! construct IPD array");
  com();
  writeSource("nowfree     = ipf(istart)");
  writeSource("ipd(istart) = 1");
  com();
  writeSource("do i=istart+1,npmax");
  writeSource("  if(ipf(i) .ne. 0) then");
  writeSource("    ipd(i) = nowfree + 1");
  writeSource("    nowfree = nowfree + ipf(i)");
  writeSource("  endif");
  writeSource("end do");
  com();
  writeSource("neq = nowfree");
  com();
  writeSource("end subroutine makeipddrama");
  com();
  writeSource("subroutine mksendlst(myrank,nprocs,mypeid,   &");
  writeSource("                     enptr,con,nelem,npmax,  &");
  writeSource("                     eflag,nflag,            &");
  writeSource("                     ne2send,nconsiz,nn2send )");
  com();
  writeSource("use numeric");
  writeSource("use feelfem90mp");
  writeSource("implicit none");
  com();
  writeSource("integer,intent(in)        :: myrank,nprocs,mypeid");
  writeSource("integer,intent(in)        :: enptr(2,*),con(2,*)");
  writeSource("integer,intent(in)        :: nelem,npmax");
  writeSource("integer,dimension(nelem)  :: eflag");
  writeSource("integer,dimension(npmax)  :: nflag");
  writeSource("integer                   :: ne2send,nconsiz,nn2send");
  com();
  writeSource("! auto variables");
  com();
  writeSource("integer                          :: i,j");
  writeSource("integer                          :: iptr");
  writeSource("integer                          :: ipos_from,ipos_to");
  writeSource("integer                          :: nodeofother       ! n of others' nodes");
  com();
  writeSource("integer,dimension(:,:),pointer   :: reqcon            ! request con array");
  writeSource("integer,dimension(:,:),pointer   :: allreqcon         ! exchange con array");
  writeSource("integer,dimension(:)  ,pointer   :: counts,displs     ! for gathervbcast");
  com();
  writeSource("!--------------------------------------------");
  writeSource("!initialization");
  com();
  com();
  writeSource("ne2send  = 0");
  writeSource("nconsiz  = 0");
  writeSource("nn2send  = 0");
  com();
  writeSource("do i=1,nelem");
  writeSource(" eflag(i) = Non");
  writeSource("end do");
  com();
  writeSource("do i=1,npmax");
  writeSource(" nflag(i) = Non");
  writeSource("end do");
  com();
  writeSource("!------------------------------------------------------------------");
  writeSource("! step 1-1");
  writeSource("! Count the other PE's node in my elements");
  writeSource("! In current implementation, duplication of sending nodes occures");
  writeSource("! In addition, construct eflag(*) array");
  writeSource("!------------------------------------------------------------------");
  writeSource("nodeofother = 0");
  writeSource("do i=1,nelem");
  writeSource("  ipos_from = enptr(1,i  )");
  writeSource("  ipos_to   = enptr(1,i+1)-1");
  com();
  writeSource("  do j=ipos_from,ipos_to");
  writeSource("    if(con(2,j) .ne. mypeid) then     ! double count occures");
  writeSource("      nodeofother = nodeofother + 1");
  writeSource("      eflag(i) = Oui");
  writeSource("    endif");
  writeSource("  end do");
  writeSource("end do");
  com();
  writeSource("if(nodeofother .eq. 0) then");
  writeSource("!!!! nullify(reqcon)                       !");
  com();
  writeSource("   allocate(reqcon(2,1))                 ! for PGI fortran");
  writeSource("else");
  writeSource("  allocate(reqcon(2,nodeofother))");
  writeSource("  iptr = 0");
  writeSource("  do i=1,nelem");
  writeSource("    ipos_from = enptr(1,i  )");
  writeSource("    ipos_to   = enptr(1,i+1)-1");
  com();
  writeSource("    do j=ipos_from,ipos_to");
  writeSource("      if(con(2,j) .ne. mypeid) then");
  writeSource("        iptr = iptr + 1");
  writeSource("        reqcon(1,iptr) = con(1,j)");
  writeSource("        reqcon(2,iptr) = con(2,j)");
  writeSource("      endif");
  writeSource("    end do");
  writeSource("  end do");
  writeSource("endif");
  com();
  writeSource("!-------------------------");
  writeSource("! step 1-2");
  writeSource("! gather/scatter");
  writeSource("!-------------------------");
  com();
  com();
  writeSource("call ff90gathervbcast2(myrank,nprocs,2,nodeofother,reqcon,  &");
  writeSource("                              allreqcon,counts,displs        )");
  writeSource("!-------------------------");
  writeSource("! step 1-3");
  writeSource("! make nflag list");
  writeSource("!-------------------------");
  writeSource("do i=1,nprocs");
  writeSource("  do j=1,counts(i)");
  writeSource("    iptr = j+ displs(i)");
  writeSource("    if(mypeid .eq. allreqcon(2,iptr) ) then");
  writeSource("      nflag(allreqcon(1,iptr)) = Oui");
  writeSource("    endif");
  writeSource("  end do");
  writeSource("end do");
  com();
  com();
  writeSource("!-------------------------");
  writeSource("! step 1-4");
  writeSource("! deallocation");
  writeSource("!-------------------------");
  writeSource("deallocate(allreqcon,counts,displs)");
  writeSource("if(associated(reqcon)) deallocate(reqcon)");
  com();
  com();
  writeSource("!---------------");
  writeSource("! step 2-1 count send buffer information for element");
  writeSource("!---------------");
  writeSource("do i=1,nelem");
  writeSource("  if(eflag(i) .eq. Oui) then");
  writeSource("    ipos_from = enptr(1,i  )");
  writeSource("    ipos_to   = enptr(1,i+1)-1");
  writeSource("    ne2send = ne2send +  1");
  writeSource("    nconsiz = nconsiz + (ipos_to-ipos_from+1)");
  writeSource("  endif");
  writeSource("end do");
  com();
  com();
  writeSource("!---------------");
  writeSource("! step 2-2 count send buffer information for node");
  writeSource("!---------------");
  writeSource("do i=1,nelem");
  writeSource("  if(eflag(i) .eq. Oui) then");
  writeSource("    ipos_from = enptr(1,i  )");
  writeSource("    ipos_to   = enptr(1,i+1)-1");
  writeSource("    do j=ipos_from,ipos_to");
  writeSource("      if(con(2,j) .eq. mypeid) then");
  writeSource("        nflag(con(1,j)) = Oui");
  writeSource("      endif");
  writeSource("    end do");
  writeSource("  endif");
  writeSource("end do");
  com();
  writeSource("!---------------");
  writeSource("! step 2-3 count total nodes to send");
  writeSource("!---------------");
  writeSource("do i=1,npmax");
  writeSource("  nn2send = nn2send + nflag(i)");
  writeSource("end do");
  com();
  writeSource("999 continue");
  writeSource("end subroutine mksendlst");
  com();
  writeSource("subroutine pnc_connect90(mypeid,npmax,enptr   ,con   ,nelem   , &");
  writeSource("                                      enptr_ex,con_ex,nelem_ex, &");
  writeSource("                                      ncmax                     )");
  com();
  writeSource("implicit none");
  writeSource("integer,intent(in)              :: mypeid,npmax");
  writeSource("integer,intent(in)              :: nelem,nelem_ex");
  writeSource("integer,dimension(2,nelem+1)    :: enptr");
  writeSource("integer                         :: con(2,*)");
  writeSource("integer,dimension(2,nelem_ex+1) :: enptr_ex");
  writeSource("integer                         :: con_ex(2,*)");
  writeSource("integer,intent(out)             :: ncmax");
  com();
  writeSource("! auto variables");
  writeSource("integer                         :: i,j");
  writeSource("integer                         :: ipos_from,ipos_to");
  writeSource("integer,dimension(:),pointer    :: nc");
  writeSource("!====================================================");
  writeSource("! nc preparation");
  com();
  writeSource("!write(*,*) '******************'");
  writeSource("!write(*,*) '**now do nothing**'");
  writeSource("!write(*,*) '******************'");
  com();
  writeSource("allocate(nc(npmax))");
  writeSource("do i=1,npmax");
  writeSource("nc(i)=0");
  writeSource("end do");
  com();
  com();
  writeSource("!---------------------------------------------------");
  writeSource("! Count the connecting elements");
  writeSource("! Part 1: my PE's element");
  writeSource("!---------------------------------------------------");
  writeSource("do i=1,nelem");
  writeSource(" ipos_from = enptr(1,i  )");
  writeSource(" ipos_to   = enptr(1,i+1)-1");
  writeSource(" do j=ipos_from,ipos_to");
  writeSource("   if(con(2,j) .eq. mypeid) then");
  writeSource("     nc(con(1,j)) = nc(con(1,j)) + 1");
  writeSource("   endif");
  writeSource(" end do");
  writeSource("end do");
  com();
  writeSource("!---------------------------------------------------");
  writeSource("! Count the connecting elements");
  writeSource("! Part 2: other PEs' element");
  writeSource("!---------------------------------------------------");
  writeSource("do i=1,nelem_ex");
  writeSource(" ipos_from = enptr_ex(1,i  )");
  writeSource(" ipos_to   = enptr_ex(1,i+1)-1");
  writeSource(" do j=ipos_from,ipos_to");
  writeSource("   if(con_ex(2,j) .eq. mypeid) then");
  writeSource("     nc(con_ex(1,j)) = nc(con_ex(1,j)) + 1");
  writeSource("   endif");
  writeSource(" end do");
  writeSource("end do");
  com();
  writeSource("!---------------------");
  writeSource("! calculate ncmax");
  writeSource("!---------------------");
  writeSource("ncmax=nc(1)");
  writeSource("do i=2,npmax");
  writeSource(" if(ncmax .lt. nc(i)) ncmax = nc(i)");
  writeSource("end do");
  com();
  writeSource("! deallocation of array nc");
  com();
  writeSource("deallocate(nc)");
  com();
  writeSource("999 continue");
  writeSource("end subroutine pnc_connect90");
  com();
  com();
  writeSource("integer function ndsearch_ex(nd,pe,ndno,peno,nouter)");
  writeSource("! search outer node number");
  writeSource("use abortmodule");
  writeSource("implicit none");
  writeSource("integer,intent(in)         :: nd,pe     ! questioned node number and PE number");
  writeSource("integer,dimension(nouter)  :: ndno,peno ! node/pe number list");
  writeSource("integer,intent(in)         :: nouter    ! number of external nodex");
  com();
  writeSource("!auto varaible");
  writeSource("integer                    :: i");
  com();
  writeSource("!================================================");
  writeSource("do i=1,nouter");
  writeSource("  if(nd .eq. ndno(i) .AND. pe .eq. peno(i)) then");
  writeSource("    ndsearch_ex = i");
  writeSource("    return");
  writeSource("  endif");
  writeSource("end do");
  com();
  writeSource("write(*,*) '[ndsearch_ex] Cannot find PE ',pe,' node ',nd");
  writeSource("call abortexit(-999)");
  com();
  writeSource("end function ndsearch_ex");
  com();
  writeSource("integer function ndsearch_ex2(nd,pe,ndno,peno,nouter)");
  writeSource("! search outer node number");
  writeSource("use numeric");
  writeSource("implicit none");
  writeSource("integer,intent(in)         :: nd,pe     ! questioned node number and PE number");
  writeSource("integer,dimension(nouter)  :: ndno,peno ! node/pe number list");
  writeSource("integer,intent(in)         :: nouter    ! number of external nodex");
  com();
  writeSource("!auto varaible");
  writeSource("integer                    :: i");
  com();
  writeSource("!================================================");
  writeSource("do i=1,nouter");
  writeSource("  if(nd .eq. ndno(i) .AND. pe .eq. peno(i)) then");
  writeSource("    ndsearch_ex2 = i");
  writeSource("    return");
  writeSource("  endif");
  writeSource("end do");
  com();
  writeSource("ndsearch_ex2 = NodeError");
  writeSource("return");
  com();
  writeSource("end function ndsearch_ex2");
  com();
  com();
  writeSource("real*8 function dramafemval(mypeid, ind,ipe,val,npmax, &");
  writeSource("                            valex,ndno,peno,nouter)");
  writeSource("!------------------------------------------------------------");
  writeSource("!    Get fem value by nd/pe double index pair");
  com();
  writeSource("!    val(npmax)");
  writeSource("!    valex(nouter),ndno(nouter),peno(nouter)");
  writeSource("!------------------------------------------------------------");
  writeSource("      integer*4 mypeid");
  writeSource("      integer*4 ind,ipe");
  writeSource("      real   *8 val(*)");
  writeSource("      integer*4 npmax");
  writeSource("      real   *8 valex(*)");
  writeSource("      integer*4 ndno(*),peno(*)");
  writeSource("      integer*4 nouter");
  writeSource("!------------------------------------------------------");
  writeSource("      if(mypeid .eq. ipe) then");
  writeSource("         dramafemval = val(ind)");
  writeSource("      else");
  com();
  writeSource("         nd = ndsearch_ex(ind,ipe,ndno,peno,nouter)");
  writeSource("         dramafemval = valex(nd)");
  writeSource("      endif");
  com();
  writeSource("      return");
  writeSource("end function dramafemval");
  writeSource("end module subSolveDrama");

  // ORIGINAL SOURCE END-------------------

  CloseSource();

  return;
}
